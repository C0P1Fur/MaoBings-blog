---
title: C++教程
date: 2025-10-24 12:53:47
tags:
 - C++
categories:     
 - tutorial
---
## 0.目录

## 1.预备知识
C++在C上的提升
- 保留了C过程性语言的特性
- 面向对象编程(OOP)
- 泛型编程
#### 1.1 C语言
C语言
- 是高级语言
    - 它致力于解决问题，而不针对特定的硬件（C语言可移植的原因）
    - 将低级语言的效率、硬件访问能力和高级语言的通用性可移植性结合
#### 1.2 面向过程编程
面向过程编程的核心思想
- 最关心的是如何解决问题
- 自上而下地去拆分问题，找到解决方案

> 关注的是，面对问题，如何“一步一步做”才能解决。

#### 1.3 面向对象编程
面向对象编程的核心思想
- 最关心的是解决问题需要的对象
- 自下而上，先构建蓝图，再去解决问题

> 编程时，不再首先关注“一步一步怎么做”，而是先思考“这个程序里涉及到哪些事物”，然后为这些事务创建“模板”（类），最后再通过模板生成具体的“实例”（对象）来协同工作。最后才解决问题。

#### 1.4 过程到对象的思考
由过程到面向对象语言的发展，是问题规模扩大之后的必然
因为随着问题规模扩大
- 面向过程语言
    - 必然需要越来越多针对性的方法去解决问题
    - 程序变得越来越臃肿，不可维护
- 面向对象语言
    - 不需要提供针对性的解决方案，只是从现有的类出发去解决问题
    - 程序能够灵活应对问题，维护性强

我对于C引进类于新动态分配内存关键字的看法：
它们是一个组合拳，类的引进使得动态内存的管理变得更方便，有条理。而动态内存又让程序更加灵活。还有泛型编程更是增加了这种灵活度。

#### 1.5 泛型编程
简化代码的编程模式
强调对**不同的数据类型**只用**一个函数处理**

#### 1.6 可移植性与标准
标准的制定，保证了C语言的可移植性
- C++98，为1998年通过的C++标准
- C++03，2003的标准第二版，修订了错误，但没有改变语法（因此我们使用C++98表示这两个版本）
- C++11，2011通过的标准，新增了众多特性

#### 1.7 编译过程
比较熟悉，跳过了

#### 1.x 补充
小知识
- C++是C的超集，任何C程序都可以在C++环境中运行
- C++中的++来源于C语言的递增运算符++
- C++集成了C的低级硬件访问与OOP高级抽象概念
- C++的源代码文件有多种扩展名（不只有cpp一种），具体取决于系统

## 2.开始学习C++
> 只记录我C语言没学过或者忘记的知识

#### 2.1 语句和分号
在C中，分号不是**语句之间的标识**，而是一个语句的组成部分，没有分号，语句就不完整

**补充:C语言中的语句类型**
- 表达式语句
    - 包含赋值表达式，函数表达式
- 控制语句
    - 条件判断，循环，跳转语句
- 复合语句
    - 大括号括起来的
- 空语句
    - 单独的一个分号会被视为一个空语句
- 声明语句
    - 声明变量的语句

**补充:C语言中的表达式类型**
- 算数表达式（返回计算结果）
    - 算数运算符计算数值
- 关系表达式（返回布尔类型）
    - 比较两个数值之间的关系
- 逻辑表达式（返回布尔类型）
    - 逻辑运算符连接的关系表达式
- 赋值表达式（返回赋值结果）
    - 将一个值赋给一个变量
- 条件表达式（返回符合条件的值）
- 逗号表达式（返回最后一个表达式的值）
    - 从左向右执行表达式
- 函数调用表达式（函数必须要有返回值）

#### 2.2 C语言注释于C++语言注释
- `//`，C++的注释风格
- `/**/`，C的注释风格
所以实际上，C并不是最开始就能兼容`//`的，直到C99标准才把它添加进去
使用C++注释风格更好一点，能避免问题

#### 2.3 C++的头文件
- C++头文件：无拓展名
- C头文件：以.h结尾
为了C++有兼容C的库，一般在头文件前添加'c'并去掉'.h'，如'cmath'
没有'.h'结尾的头文件，默认都是有名称空间的，这是C++的特性

#### 2.4 名称空间
相当于一个包裹，将代码打包，当日后要用到包裹中的函数时，就要指定包裹避免名称冲突
> using namespace xxx; 是一个偷懒的做法，它为方便这个特性之前出现的项目提供，这样就不需要对为适应C++对代码进行过多修改
```
using namespace xxx; //引入整个名称空间
using namespace xxx:yyy; //引入名称空间里的某个项
```

#### 2.5 运算符重载
即同一个运算符可以有不同的含义，这个含义由上下文确定
C++的特性使我们能够定义这些运算符的操作

**重载**这个词，在泛型编程里也经常被提到，我的理解是：
对于同一个符号，在不同的情况下，会做出不同的反应

#### 2.6 \n与endl的区别
endl能够保证刷新输出，而\n不能保证

#### 2.7 赋值运算符
C与C++都有这个特性，也就是赋值运算符能够连续使用
`a = b = c //合法的`
赋值将从右向左进行

#### 2.8 类简介
类是蓝图，而对象则是按照蓝图做的实体
类之于对象，就像类型之于变量

而不同的是，类型是内置于C++中，作为语言的一部分的
而类则是由用户定义的

#### 2.9 main的返回值去哪了？
将操作系统看为调用main函数的对象，main函数的返回值最后回到了操作系统
实际上，main返回0值，代表程序成功运行，非0值则表示不成功

## 3.变量类型
#### 3.1 sizeof的使用
对于类型名，sizeof必须要加括号
对于变量名，sizeof的括号是可选的

#### 3.2 大括号初始化方式
```
int var1{5};
int var2 = {6};
```
以上是大括号初始化器的两种使用方法，等号是可选的
同时，空大括号将变量初始化为0

#### 3.3 整形常量的三种表示方式
```
int var1 = 123;
int var2 = 0123;
int var3 = 0x123;
```
整形常量，以1开头表示十进制，以0开头表示八进制，以0x开头表示十六进制

```
cout << hex;
cout << oct;
```
使用cout时，输入控制符hex以十六进制显示，oct以八进制显示
在再次切换之前进制进制显示设置一直有效

#### 3.4 类型大小
整形
- short 至少16位
- int 至少与short一样长
- long 至少32位，且至少与int一样长
- long long 至少64位，且至少与long long一样长
> 在windows下，int与long都位32位
> long long为64位

浮点形
- float 32位，其中1位符号位，8位指数位，23为尾数位
- double 64位，其中1位符号位，11位指数位，52位尾数位
> 在C中，使用0.1 + 0.2 == 0.3得到的的将是false
> 因为浮点数并不能精确地表示0.1与0.2
> 最后相加的结果不等于0.3的字面量值

#### 3.5 C++数值转换
C++转换自动执行的情况
- A类型赋值给B类型时
- 同一表达式存在不同类型的值时
- 给函数传递参数时

数值转换时缩窄（narrowing）的情况
- double->float
- 浮点->整形
- 大整形->小整形

```
char a{1234} //不允许
char a = {12} //允许，因为没有缩窄
```
使用{}初始化，它会严格检查类型，不允许缩窄的情况

表达式中的转换
可以简单地这样理解：取表达式里最大的类型，将其他类型都转换为此类型

强制类型转换
```
(long) a // 为表达式，返回转换为long类型的a值
long (a) // 函数调用版
```
同时C++还有更严格的类型转换方法
```
static_cast<int>(a) // 返回a的int类型
```

## 4.复合类型
> 复合类型，由基本类型构成
> C++中的复合类型包括
> 数组
> 结构
> 指针
> 类
#### 4.1 拼接字符串常量
C++中，由空白字符分隔的字符串常量都会被拼接为一个

#### 4.2 读取一整行
```
cin.getline(size, ptr); //读取一整行，并丢弃换行符
cin.get(size, ptr); //读取一整行，并将换行符留在输入流中
```
表达式返回cin对象，因此，读取两行可以这样使用
`cin.getline(size, ptr).getline(size, ptr);`

#### 4.3 string类简介
C++98标准新增了string类型
对于字符串，string隐去了数组特性，让它更像普通类型
下面程序展示了基于string类型的IO方法
```
    string fName; //不需要提前指定大小，大小可变
    string lName;
    string description{"description: "} // 同样也可以初始化;
    string container;

    cout << "Enter your first name and last name:" << endl;
    getline(cin, fName), getline(cin, lName);
    // cin没有处理string的方法，所以需要额外使用getline

    cout << "Enter your desciption" << endl;
    getline(cin, container);
    description += container; // 忽略数组特性，像对象一样操作

    cout << "your name is: " << fName << " " << lName << endl;
    cout << description << endl;
    cout << description[2] << endl;
```

#### 4.4 枚举
```
enum orientation{west, east, north, south};
enum {left, right, up, down};
```
一次性定义多个整形常量
也可以给枚举取名，限定枚举变量的值

#### 4.5 使用new分配内存
```
int * newptr = new int;
int * newarray = new int [10];
int * mallocptr = malloc(sizeof(int));

delete int;
delete [] int;
free(mallocptr);
```
new，是C++提供的新关键字，用于动态分配内存
它与malloc的不同点在于
- new分配的是称为“堆”的自由内存，malloc是“栈”内存
- new分配的内存必须用delete释放，malloc需要free
- new分配的数组，必须要用数组形式对应释放

#### 4.6 auto类型的使用方法
`auto container = /*一个指向存放整形数组指针数组的指针*/`
在变量类型复杂时，可以直接用auto代替

#### 4.7 vector与array模板类简介
```
vector<int> vi(n); // n可以是变量
array<double, n> vd; // n可以是变量
```
vector与array提供了动态管理数组的功能，可以代替数组而且更安全
可以使用vector与array的类方法来动态分配数组，将在后面提到
但是vector相比于数组，处理时间更长一些

## 5.循环与关系表达式

#### 5.1 副作用与顺序点
顺序点，是程序执行过程中的一个点，进行下一步之前确保对所有副作用都做出了评估
在C++中，语句中的分号就是一个顺序点
同时，任何完整表达式的最后都是一个顺序点
如`while (i++ < 5)`，i++ < 5是一个完整条件表达式，因为他是while循环的测试条件

#### 5.2 编写延时循环
头文件`ctime`中提供了clock_t类型与CLOCK_PER_SECOND常量
目的是为了统一ctime在不同系统上的运行结果
```
    float seconds;
    cout << "Enter the delay time, in seconds:";
    cin >> seconds;
    clock_t delay = seconds * CLOCKS_PER_SEC; // 计算延时的时间戳

    cout << "delaying..." << endl;
    clock_t start = clock();
    while (clock() - start < delay); // 这种循环等待的方式实际上会占用电脑大量资源

    cout << "done!" << endl;
```

#### 5.3 基于范围的for循环
```
double x[4]{0.1, 5.0, 2.3, 4.2};

for (double i : x) // x必须是数组或者容器类型
    cout << i << " ";
cout << endl;
```
对于使用for循环遍历容器元素，C++11提供了遍历的新特性

#### 5.4 cin.get的重载类型