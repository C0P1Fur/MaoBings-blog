---
title: 刷题笔记&反思
date: 2025-10-28 19:58:09
tags:
 - notes
categories:
 - algorithm
---

## P1059
类型：双指针 | 排序
#### 题目描述
明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N 个 1 到 1000 之间的随机整数 (N≤100)，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

输入格式
输入有两行，第 1 行为 1 个正整数，表示所生成的随机数的个数 N。

第 2 行有 N 个用空格隔开的正整数，为所产生的随机数。

输出格式
输出也是两行，第 1 行为 1 个正整数 M，表示不相同的随机数的个数。

第 2 行为 M 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。

```
#include <iostream>

using namespace std;

const int N = 110;
int a[N];
int n;

void quick_sort(int l, int r)
{
    if (l >= r) return;
    int x = a[l + r >> 1], i = l - 1, j = r + 1;

    while (i < j)
    {
        do i++; while(a[i] < x);
        do j--; while(a[j] > x);
        if (i < j) swap(a[i], a[j]);
    }
    quick_sort(l, j), quick_sort(j + 1, r);
}

int main(void)
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    quick_sort(0, n - 1);

    int count = 1;
    for (int p1 = 0, p2 = 1; p2 < n; p2++)
    {
        if (a[p1] < a[p2])
        {
            p1++;
            a[p1] = a[p2];
            count++;
        }
    }

    cout << count << endl;
    for (int i = 0; i < count; i++)
        cout << a[i] << " ";
}
```

#### 总结
**我对for循环的理解**
for (1; 2; 3)

对于2边界条件的思考
- 代码块被执行时，判断条件都是满足的
    - 如`for( ; i < n; )`，在整个for循环代码块的执行过程中，i都是小于n的
- 最后变量的状态是，变量最后一次执行的状态 + 3中修改的状态
    - 如`for ( ; i < n; i++)`，最后i的状态是，i = n - 1，最后再 ++1

**双指针去重算法**
记住有这种线性的去重算法，前提是数组是有序的
核心概念就是
**把不重复的元素都放在数组前面去**
这一个操作需要两个定位点，也就是前指针和后指针，才能完成这个**交换**操作
类似的思想还有快速排序中的交换

## ackwing 800 数组元素的目标和
类型：双指针
#### 题目描述
给定两个升序排序的有序数组 A 和 B ，以及一个目标值 x 。

数组下标从 0 开始。

请你求出满足 A[i]+B[j]=x 的数对 (i,j) 。

数据保证有唯一解。

输入格式
第一行包含三个整数 n,m,x
，分别表示 A 的长度，B 的长度以及目标值 x

第二行包含 n 个整数，表示数组 A

第三行包含 m 个整数，表示数组 B

输出格式 
共一行，包含两个整数 i 和 j

数据范围
数组长度不超过 10^5
同一数组内元素各不相同。
1≤数组元素≤10^9

```
#include <iostream>

using namespace std;
const int N = 1e5 + 10;
int a[N], b[N];
int n, m, k;

int main(void)
{
    scanf("%d %d %d", &n, &m, &k);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    for (int i = 0; i < m; i++) scanf("%d", &b[i]);
    
    int l = 0, r = m - 1;
    while (a[l] + b[r] != k) // 一定有可能解，所以不用框定范围
    {
        while (a[l] + b[r] > k) r--;
        while (a[l] + b[r] < k) l++;
    }
    
    
    cout << l << " " << r;
}
```

不一定有可能解版本
```
for (int i = 0, j = m - 1; i < n; i ++) {
    while(j >= 0 && a[i] + b[j] > k) j --;
    if(j >= 0 && a[i] + b[j] == k) printf("%d %d\n", i, j);
}
```

二分版本
```
    for (int i = 0; i < n; i++)
    {
        int y = x - a[i];
        int l = 0, r = m - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (b[mid] >= y) r = mid;
            else l = mid + 1;
        }
        if (b[l] == y)
        {
            printf("%d %d", i, l);
            break;
        }
    }
```

#### 总结
