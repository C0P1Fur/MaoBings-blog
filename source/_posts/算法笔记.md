---
title: 算法笔记
date: 2025-10-22 20:35:39
tags:
 - note
categories:
 - algorithm
feature: true
---
## 0.本节课内容列表
- 排序
    - 快速排序
    - 归并排序
- 二分
    - 整数二分
    - 浮点数二分

课时要做的
- 理解算法思想
课后要做的
- 理解并且背（快速默写模板）
- 默写，用题来练默写
- 重复默写模板

## 1.排序
#### 1.1快速排序
性质：平均时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2)

主要思想
- 最核心的思路：分而治之，将大问题分成一个个小问题
- 具体实现
    - 定义一个左边界和右边界，圈出范围
    - 在范围里随机取数，一般取中间的，设为x
    - 将小于x的数排在x左边，大于的排在右边
    - 此时范围被分为两部分：左半小，右半大
    - 继续对左半与右半执行一遍这个过程

代码范例，最核心的代码段是quick_sort
```
#include<iostream>

using namespace std;

const int N = 1e6 + 10; // + 10防止数组越界，是一种缓冲区
int n;
int a[N];

void quick_sort(int * a, int l, int r) //l表示left，r表示right
{
    if (l >= r) return;
    
    /**
    * l + r >> 1表达式与(l + r) / 2效果一样
    * 但是更快而且更简便
    * 
    * l + r >> 1默认是向下取整
    * 使用 l + r + 1 >> 1可以向上取整
    * 
    * 同时，将x去中间的一个数可以避免死循环
    */
    int x = a[l + r >> 1], i = l - 1, j = r + 1;
    while (i < j)
    {
        do i++; while (a[i] < x);
        do j--; while (a[j] > x);
        if (i < j) swap(a[i], a[j]);
    }
    
    /**
    * 这里要么写l, j 要么写l，i - 1
    * 因为最后要将数组一分为二
    * i 与 j的大小就有两种情况
    * - i == j，此时两种方法的效果是一样的
    * - j < i，此时j指向数组的左半部分，就不能向左偏移了，i同理
    */
    quick_sort(a, l, j);
    quick_sort(a, j + 1, r);
}

int main(void)
{
    scanf("%d", &n); //用scanf读取数据比cin要快一点
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    
    quick_sort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    
    return 0;
}
```

#### 1.1(2) 快速选择排序
选择一遍递归，而不是两边都递归
所以时间复杂度为n + n / 2 + n / 4 + n / 8 + ... < 2n
所以时间复杂度为O(n)

#### 1.2 归并排序
性质：时间复杂度稳定为nlogn

思想
- 将数组不断划分，分为很小的部分
- 对小部分进行排序，这下我们得到了两个顺序数组
- 将两个小部分合成，又得到了新的顺序数组
- 不断合成，最后结果为原来的大数组

代码实现
```
void merge_sort(int * a, int l, int r)
{
    if (l >= r) return;
    int mid = l + r >> 1;
    
    // 切分操作
    merge_sort(a, l, mid), merge_sort(a, mid + 1, r);
    
    //排序操作
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
    {
        if (a[i] <= a[j]) t[k++] = a[i++];
        else t[k++] = a[j++];
    }
    while (i <= mid) t[k++] = a[i++];
    while (j <= r) t[k++] = a[j++];
    
    for (i = 0, j = l; j <= r; i++, j++) a[j] = t[i];
}
```

## 2.二分
#### 2.1 整数二分
有单调性一定可以二分，二分不一定需要单调性
二分思想的本质
- 现有一数组，有一值，在数组里找值
- 通过对数组中点性质的比较，可以缩小值的范围
- 不断缩小，最后精确找到值

代码实现
```
// 最终结果：l == r，指向答案
// 特点：这种模板不存在找不到的情况，找不到需要按照题意单独判断
// 特点：一定可以把符合性质的范围二分出来
// 选择：当check为true使，右边界收缩时，就用第一种，反之第二种
int bsearch1(int l, int r)
{
    while (l < r)
    {
        mid = l + r >> 1;
        if (check()) r = mid;
        else l = mid + 1;
    }
    return l;
}

int bsearch2(int l, int r)
{
    while (l < r)
    {
        mid = l + r + 1 >> 1;
        if (check()) l = mid;
        else r = mid - 1;
    }
}
```

整数二分的另外一个模板
```
int bsearch3(int l, int r)
{
    int mid;
    while (l + 1 < r)
    {
        mid = l + r >> 1;
        if (check()) l = mid;
        else r = mid;
    }
}
```

#### 2.2浮点数二分
和整数二分类似，只不过**不用考虑向下或是向上取整问题**
代码实现
```
double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l; //返回l或者r的一个
}
```
## 3.高精度
三种情况
- 大整数相加（数量级为位数10^6）
- 大整数相减
- 大整数乘小整数（数量级大整数位数10^6，小整数小于10^5）
- 大整数除小整数
#### 3.1 大整数相加
```
#include <iostream>
#include <string>
#include <vector>

using namespace std;

const int N = 1e5 + 10;

vector<int> add(vector<int> &a, vector<int> &b) //这里加上引用，也能防止拷贝数据节省内存
{
    vector<int> c;
    int t = 0; //所有的位处理，都用t完成
    
    //这里很妙，不用考虑数组越界的问题
    //就是不管三七二十一继续循环，在代码块里判断有没有越界就是了
    for (int i = 0; i < a.size() || i < b.size(); i++)
    {
        if (i < a.size()) t += a[i];
        if (i < b.size()) t += b[i];
        
        c.push_back(t % 10);
        t = t / 10;
    }
    
    if (t) c.push_back(t);
    return c;
}

int main(void)
{
    string a, b; //用string有两个好处，一是不用考虑越界问题，二是可以动态分配内存
    vector<int> n1, n2, n3; //用vector也有动态分配内存的好处
    
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i--) n1.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i--) n2.push_back(b[i] - '0');
    
    n3 = add(n1, n2);
    
    for (int i = n3.size() - 1; i >= 0; i--) printf("%d", n3[i]);
}
```

核心思路
1. 字符串读取大整数
2. 用数组逆序存储
3. 用数组进行计算
4. 逆序输出

#### 3.2 大整数除法
```
//判断是否a >= b
bool cmp(vector<int> a, vector<int> b)
{
    if (a.size() > b.size()) return true;
    else if (a.size() < b.size()) return false;
    else{
        for (int i = a.size() - 1; i >= 0; i--)
        {
            if (a[i] > b[i]) return true;
            else if (a[i] < b[i]) return false;
        }
        return true;
    }
}

// 默认a >= b
// 不取minus是因为内置函数有这个名
vector<int> sub(vector<int> a, vector<int> b)
{
    vector<int> c;
    for (int i = 0, t = 0; i < a.size(); i++) // a, b, c共用i的原因是，它们的定位都是相同的
    {
        t = a[i] - t;
        if (i < b.size()) t -= b[i];
        
        c.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
    
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    return c;
}

int main(void)
{
    if (cmp(n1, n2))
    {
        auto n3 = sub(n1, n2);
        for (int i = n3.size() - 1; i >= 0; i--) cout << n3[i];
    }
    else
    {
        auto n3 = sub(n2, n1);
        cout << "-";
        for (int i = n3.size() - 1; i >= 0; i--) cout << n3[i];
    }
}
```

#### 3.3 大整数乘小整数
```
vector<int> multi(vector<int> &a, int &b)
{
    vector<int> c;
    int t = 0;
    
    for (int i = 0; t || i < a.size(); i++)
    {
        if (i < a.size()) t += a[i] * b;
        c.push_back(t % 10);
        t = t / 10;
    }
    
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    
    return c;
}
```
直用小整数乘上大整数的每一位
如果再将小整数读成数组一位一位算就复杂了

#### 3.4 大整数除小整数
```
//为了保证代码的统一性，a同样是逆序
//虽然a顺序用除法处理起来更方便一些
vector<int> div(const vector<int> &a, int b, int &r)
{
    vector<int> c;
    r = 0;
    
    for (int i = a.size() - 1; i >= 0; i--)
    {
        r = r * 10 + a[i];
        c.push_back(r / b);
        
        r = r % b;
    } //最后不需要额外的边界处理
    
    reverse(c.begin(), c.end()); //c是反着输出的，所以要调转顺序
    
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    return c;
}
```

## 4.前缀和与差分
#### 4.1 前缀和
```
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

为什么需要前缀和？
当需要重复计算区间[l, r]之间的数据和的时候，每次计算的时间复杂度是O(n)
但计算一次前缀和数列后，每一计算的时间复杂度为O(1)

#### 4.2 前缀和矩阵
```
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

补充说明：矩阵的和，等于从某个坐标开始，左上角所有数字的和

#### 4.3 差分
```
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
只需要一个insert(l, r, c)操作
```

差分就是前缀和的逆运算，也就是给定数组，算差分数组，数组就是差分数组的前缀和数组
使用情况：在某个区间给所有数加上一个数

差分不需要额外操作来构建，只需构想一个空差分组，用insert方法在[i, i]处加上ai即可构建

#### 4.4 差分矩阵
```
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
同样只需要一个insert操作
```

## 5.双指针算法
思想：涉及到两个指针的操作
有几种情况：
- 指向两个不同的序列
    - 归并排序，两个指针分别确定操作位置
- 指向一个序列
    - 快速排序，两个指针确定区间

双指针算法的具体模板
```
for (int i = 0, j = 0; i < n; i++)
{
    while (j < i && check(i, j)) j++;

    // 每道题目的具体逻辑
}
```
i与j移动的次数不超过n，因此时间复杂度为O(n)

双指针问题如何思考
先思考如何暴力解决问题
再在暴力解决问题的基础上发现单调性
如最长不重复子序列，左右指针得同时向前移动，这样就可以将复杂度降到2n
```
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int a[N];
char s[N]; // 存储数字的重复状态
int n, res;

int main(void)
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    
    for (int i = 0, j = 0; i < n; i++) // i与j区间内必须保证没有重复元素
    {
        s[a[i]]++;
        while (j < i && s[a[i]] > 1)
        {
            s[a[j]]--;
            j++;
        }
        
        res = max(res, i - j + 1);
    }
    
    cout << res;
}
```

使用注意：
必须时刻保证指针不越界，所以要在必要的地方加上限定条件

## 6.位运算
#### 6.1 第k位数
二进制数 1 0 1 0
对应下标 3 2 1 0

1. 将第k位数移动到0位
2. 再将数与上1

#### 6.2 返回最后一位1
如101000，返回1000

最后一位1就是：
lowbit(x) = x & (~x + 1)

应用：可以统计x里1的个数