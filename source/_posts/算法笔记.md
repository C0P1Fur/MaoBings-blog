---
title: 算法笔记
date: 2025-10-22 20:35:39
tags:
 - note
categories:
 - algorithm
feature: true
---
## 0.本节课内容列表
- 排序
    - 快速排序
    - 归并排序
- 二分
    - 整数二分
    - 浮点数二分

课时要做的
- 理解算法思想
课后要做的
- 理解并且背（快速默写模板）
- 默写，用题来练默写
- 重复默写模板

## 1.排序
#### 1.1快速排序
性质：平均时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2)

主要思想
- 最核心的思路：分而治之，将大问题分成一个个小问题
- 具体实现
    - 定义一个左边界和右边界，圈出范围
    - 在范围里随机取数，一般取中间的，设为x
    - 将小于x的数排在x左边，大于的排在右边
    - 此时范围被分为两部分：左半小，右半大
    - 继续对左半与右半执行一遍这个过程

代码范例，最核心的代码段是quick_sort
```
#include<iostream>

using namespace std;

const int N = 1e6 + 10; // + 10防止数组越界，是一种缓冲区
int n;
int a[N];

void quick_sort(int * a, int l, int r) //l表示left，r表示right
{
    if (l >= r) return;
    
    /**
    * l + r >> 1表达式与(l + r) / 2效果一样
    * 但是更快而且更简便
    * 
    * l + r >> 1默认是向下取整
    * 使用 l + r + 1 >> 1可以向上取整
    * 
    * 同时，将x去中间的一个数可以避免死循环
    */
    int x = a[l + r >> 1], i = l - 1, j = r + 1;
    while (i < j)
    {
        do i++; while (a[i] < x);
        do j--; while (a[j] > x);
        if (i < j) swap(a[i], a[j]);
    }
    
    /**
    * 这里要么写l, j 要么写l，i - 1
    * 因为最后要将数组一分为二
    * i 与 j的大小就有两种情况
    * - i == j，此时两种方法的效果是一样的
    * - j < i，此时j指向数组的左半部分，就不能向左偏移了，i同理
    */
    quick_sort(a, l, j);
    quick_sort(a, j + 1, r);
}

int main(void)
{
    scanf("%d", &n); //用scanf读取数据比cin要快一点
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    
    quick_sort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    
    return 0;
}
```
#### 1.2 归并排序
性质：时间复杂度稳定为nlogn

思想
- 将数组不断划分，分为很小的部分
- 对小部分进行排序，这下我们得到了两个顺序数组
- 将两个小部分合成，又得到了新的顺序数组
- 不断合成，最后结果为原来的大数组

代码实现
```
void merge_sort(int * a, int l, int r)
{
    if (l >= r) return;
    int mid = l + r >> 1;
    
    // 切分操作
    merge_sort(a, l, mid), merge_sort(a, mid + 1, r);
    
    //排序操作
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
    {
        if (a[i] <= a[j]) t[k++] = a[i++];
        else t[k++] = a[j++];
    }
    while (i <= mid) t[k++] = a[i++];
    while (j <= r) t[k++] = a[j++];
    
    for (i = 0, j = l; j <= r; i++, j++) a[j] = t[i];
}
```

## 2.二分
#### 2.1 整数二分
有单调性一定可以二分，二分不一定需要单调性
二分思想的本质
- 现有一数组，有一值，在数组里找值
- 通过对数组中点性质的比较，可以缩小值的范围
- 不断缩小，最后精确找到值

代码实现
```
// 最终结果：l == r，指向答案
// 特点：这种模板不存在找不到的情况，找不到需要按照题意单独判断
// 特点：一定可以把符合性质的范围二分出来
// 选择：当check为true使，右边界收缩时，就用第一种，反之第二种
int bsearch1(int l, int r)
{
    while (l < r)
    {
        mid = l + r >> 1;
        if (check()) r = mid;
        else l = mid + 1;
    }
    return l;
}

int bsearch2(int l, int r)
{
    while (l < r)
    {
        mid = l + r + 1 >> 1;
        if (check()) l = mid;
        else r = mid - 1;
    }
}
```
#### 2.2浮点数二分
和整数二分类似，只不过**不用考虑向下或是向上取整问题**
代码实现
```
double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l; //返回l或者r的一个
}
```