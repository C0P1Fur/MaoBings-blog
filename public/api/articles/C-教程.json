{"title":"C++教程","uid":"84dd61f8b313822c2cc9ae03433e502e","slug":"C-教程","date":"2025-10-24T04:53:47.000Z","updated":"2025-11-08T05:42:59.478Z","comments":true,"path":"api/articles/C-教程.json","keywords":"Catice, 猫冰","cover":null,"content":"<h2 id=\"0-目录\"><a href=\"#0-目录\" class=\"headerlink\" title=\"0.目录\"></a>0.目录</h2><h2 id=\"1-预备知识\"><a href=\"#1-预备知识\" class=\"headerlink\" title=\"1.预备知识\"></a>1.预备知识</h2><p>C++在C上的提升</p>\n<ul>\n<li>保留了C过程性语言的特性</li>\n<li>面向对象编程(OOP)</li>\n<li>泛型编程</li>\n</ul>\n<h4 id=\"1-1-C语言\"><a href=\"#1-1-C语言\" class=\"headerlink\" title=\"1.1 C语言\"></a>1.1 C语言</h4><p>C语言</p>\n<ul>\n<li>是高级语言<ul>\n<li>它致力于解决问题，而不针对特定的硬件（C语言可移植的原因）</li>\n<li>将低级语言的效率、硬件访问能力和高级语言的通用性可移植性结合</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2-面向过程编程\"><a href=\"#1-2-面向过程编程\" class=\"headerlink\" title=\"1.2 面向过程编程\"></a>1.2 面向过程编程</h4><p>面向过程编程的核心思想</p>\n<ul>\n<li>最关心的是如何解决问题</li>\n<li>自上而下地去拆分问题，找到解决方案</li>\n</ul>\n<blockquote>\n<p>关注的是，面对问题，如何“一步一步做”才能解决。</p>\n</blockquote>\n<h4 id=\"1-3-面向对象编程\"><a href=\"#1-3-面向对象编程\" class=\"headerlink\" title=\"1.3 面向对象编程\"></a>1.3 面向对象编程</h4><p>面向对象编程的核心思想</p>\n<ul>\n<li>最关心的是解决问题需要的对象</li>\n<li>自下而上，先构建蓝图，再去解决问题</li>\n</ul>\n<blockquote>\n<p>编程时，不再首先关注“一步一步怎么做”，而是先思考“这个程序里涉及到哪些事物”，然后为这些事务创建“模板”（类），最后再通过模板生成具体的“实例”（对象）来协同工作。最后才解决问题。</p>\n</blockquote>\n<h4 id=\"1-4-过程到对象的思考\"><a href=\"#1-4-过程到对象的思考\" class=\"headerlink\" title=\"1.4 过程到对象的思考\"></a>1.4 过程到对象的思考</h4><p>由过程到面向对象语言的发展，是问题规模扩大之后的必然<br>因为随着问题规模扩大</p>\n<ul>\n<li>面向过程语言<ul>\n<li>必然需要越来越多针对性的方法去解决问题</li>\n<li>程序变得越来越臃肿，不可维护</li>\n</ul>\n</li>\n<li>面向对象语言<ul>\n<li>不需要提供针对性的解决方案，只是从现有的类出发去解决问题</li>\n<li>程序能够灵活应对问题，维护性强</li>\n</ul>\n</li>\n</ul>\n<p>我对于C引进类于新动态分配内存关键字的看法：<br>它们是一个组合拳，类的引进使得动态内存的管理变得更方便，有条理。而动态内存又让程序更加灵活。还有泛型编程更是增加了这种灵活度。</p>\n<h4 id=\"1-5-泛型编程\"><a href=\"#1-5-泛型编程\" class=\"headerlink\" title=\"1.5 泛型编程\"></a>1.5 泛型编程</h4><p>简化代码的编程模式<br>强调对<strong>不同的数据类型</strong>只用<strong>一个函数处理</strong></p>\n<h4 id=\"1-6-可移植性与标准\"><a href=\"#1-6-可移植性与标准\" class=\"headerlink\" title=\"1.6 可移植性与标准\"></a>1.6 可移植性与标准</h4><p>标准的制定，保证了C语言的可移植性</p>\n<ul>\n<li>C++98，为1998年通过的C++标准</li>\n<li>C++03，2003的标准第二版，修订了错误，但没有改变语法（因此我们使用C++98表示这两个版本）</li>\n<li>C++11，2011通过的标准，新增了众多特性</li>\n</ul>\n<h4 id=\"1-7-编译过程\"><a href=\"#1-7-编译过程\" class=\"headerlink\" title=\"1.7 编译过程\"></a>1.7 编译过程</h4><p>比较熟悉，跳过了</p>\n<h4 id=\"1-x-补充\"><a href=\"#1-x-补充\" class=\"headerlink\" title=\"1.x 补充\"></a>1.x 补充</h4><p>小知识</p>\n<ul>\n<li>C++是C的超集，任何C程序都可以在C++环境中运行</li>\n<li>C++中的++来源于C语言的递增运算符++</li>\n<li>C++集成了C的低级硬件访问与OOP高级抽象概念</li>\n<li>C++的源代码文件有多种扩展名（不只有cpp一种），具体取决于系统</li>\n</ul>\n<h2 id=\"2-开始学习C\"><a href=\"#2-开始学习C\" class=\"headerlink\" title=\"2.开始学习C++\"></a>2.开始学习C++</h2><blockquote>\n<p>只记录我C语言没学过或者忘记的知识</p>\n</blockquote>\n<h4 id=\"2-1-语句和分号\"><a href=\"#2-1-语句和分号\" class=\"headerlink\" title=\"2.1 语句和分号\"></a>2.1 语句和分号</h4><p>在C中，分号不是<strong>语句之间的标识</strong>，而是一个语句的组成部分，没有分号，语句就不完整</p>\n<p><strong>补充:C语言中的语句类型</strong></p>\n<ul>\n<li>表达式语句<ul>\n<li>包含赋值表达式，函数表达式</li>\n</ul>\n</li>\n<li>控制语句<ul>\n<li>条件判断，循环，跳转语句</li>\n</ul>\n</li>\n<li>复合语句<ul>\n<li>大括号括起来的</li>\n</ul>\n</li>\n<li>空语句<ul>\n<li>单独的一个分号会被视为一个空语句</li>\n</ul>\n</li>\n<li>声明语句<ul>\n<li>声明变量的语句</li>\n</ul>\n</li>\n</ul>\n<p><strong>补充:C语言中的表达式类型</strong></p>\n<ul>\n<li>算数表达式（返回计算结果）<ul>\n<li>算数运算符计算数值</li>\n</ul>\n</li>\n<li>关系表达式（返回布尔类型）<ul>\n<li>比较两个数值之间的关系</li>\n</ul>\n</li>\n<li>逻辑表达式（返回布尔类型）<ul>\n<li>逻辑运算符连接的关系表达式</li>\n</ul>\n</li>\n<li>赋值表达式（返回赋值结果）<ul>\n<li>将一个值赋给一个变量</li>\n</ul>\n</li>\n<li>条件表达式（返回符合条件的值）</li>\n<li>逗号表达式（返回最后一个表达式的值）<ul>\n<li>从左向右执行表达式</li>\n</ul>\n</li>\n<li>函数调用表达式（函数必须要有返回值）</li>\n</ul>\n<h4 id=\"2-2-C语言注释于C-语言注释\"><a href=\"#2-2-C语言注释于C-语言注释\" class=\"headerlink\" title=\"2.2 C语言注释于C++语言注释\"></a>2.2 C语言注释于C++语言注释</h4><ul>\n<li><code>//</code>，C++的注释风格</li>\n<li><code>/**/</code>，C的注释风格<br>所以实际上，C并不是最开始就能兼容<code>//</code>的，直到C99标准才把它添加进去<br>使用C++注释风格更好一点，能避免问题</li>\n</ul>\n<h4 id=\"2-3-C-的头文件\"><a href=\"#2-3-C-的头文件\" class=\"headerlink\" title=\"2.3 C++的头文件\"></a>2.3 C++的头文件</h4><ul>\n<li>C++头文件：无拓展名</li>\n<li>C头文件：以.h结尾<br>为了C++有兼容C的库，一般在头文件前添加’c’并去掉’.h’，如’cmath’<br>没有’.h’结尾的头文件，默认都是有名称空间的，这是C++的特性</li>\n</ul>\n<h4 id=\"2-4-名称空间\"><a href=\"#2-4-名称空间\" class=\"headerlink\" title=\"2.4 名称空间\"></a>2.4 名称空间</h4><p>相当于一个包裹，将代码打包，当日后要用到包裹中的函数时，就要指定包裹避免名称冲突</p>\n<blockquote>\n<p>using namespace xxx; 是一个偷懒的做法，它为方便这个特性之前出现的项目提供，这样就不需要对为适应C++对代码进行过多修改</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using namespace xxx; //引入整个名称空间</span><br><span class=\"line\">using namespace xxx:yyy; //引入名称空间里的某个项</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-运算符重载\"><a href=\"#2-5-运算符重载\" class=\"headerlink\" title=\"2.5 运算符重载\"></a>2.5 运算符重载</h4><p>即同一个运算符可以有不同的含义，这个含义由上下文确定<br>C++的特性使我们能够定义这些运算符的操作</p>\n<p><strong>重载</strong>这个词，在泛型编程里也经常被提到，我的理解是：<br>对于同一个符号，在不同的情况下，会做出不同的反应</p>\n<h4 id=\"2-6-n与endl的区别\"><a href=\"#2-6-n与endl的区别\" class=\"headerlink\" title=\"2.6 \\n与endl的区别\"></a>2.6 \\n与endl的区别</h4><p>endl能够保证刷新输出，而\\n不能保证</p>\n<h4 id=\"2-7-赋值运算符\"><a href=\"#2-7-赋值运算符\" class=\"headerlink\" title=\"2.7 赋值运算符\"></a>2.7 赋值运算符</h4><p>C与C++都有这个特性，也就是赋值运算符能够连续使用<br><code>a = b = c //合法的</code><br>赋值将从右向左进行</p>\n<h4 id=\"2-8-类简介\"><a href=\"#2-8-类简介\" class=\"headerlink\" title=\"2.8 类简介\"></a>2.8 类简介</h4><p>类是蓝图，而对象则是按照蓝图做的实体<br>类之于对象，就像类型之于变量</p>\n<p>而不同的是，类型是内置于C++中，作为语言的一部分的<br>而类则是由用户定义的</p>\n<h4 id=\"2-9-main的返回值去哪了？\"><a href=\"#2-9-main的返回值去哪了？\" class=\"headerlink\" title=\"2.9 main的返回值去哪了？\"></a>2.9 main的返回值去哪了？</h4><p>将操作系统看为调用main函数的对象，main函数的返回值最后回到了操作系统<br>实际上，main返回0值，代表程序成功运行，非0值则表示不成功</p>\n<h2 id=\"3-变量类型\"><a href=\"#3-变量类型\" class=\"headerlink\" title=\"3.变量类型\"></a>3.变量类型</h2><h4 id=\"3-1-sizeof的使用\"><a href=\"#3-1-sizeof的使用\" class=\"headerlink\" title=\"3.1 sizeof的使用\"></a>3.1 sizeof的使用</h4><p>对于类型名，sizeof必须要加括号<br>对于变量名，sizeof的括号是可选的</p>\n<h4 id=\"3-2-大括号初始化方式\"><a href=\"#3-2-大括号初始化方式\" class=\"headerlink\" title=\"3.2 大括号初始化方式\"></a>3.2 大括号初始化方式</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int var1&#123;5&#125;;</span><br><span class=\"line\">int var2 = &#123;6&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上是大括号初始化器的两种使用方法，等号是可选的<br>同时，空大括号将变量初始化为0</p>\n<h4 id=\"3-3-整形常量的三种表示方式\"><a href=\"#3-3-整形常量的三种表示方式\" class=\"headerlink\" title=\"3.3 整形常量的三种表示方式\"></a>3.3 整形常量的三种表示方式</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int var1 = 123;</span><br><span class=\"line\">int var2 = 0123;</span><br><span class=\"line\">int var3 = 0x123;</span><br></pre></td></tr></table></figure>\n<p>整形常量，以1开头表示十进制，以0开头表示八进制，以0x开头表示十六进制</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; hex;</span><br><span class=\"line\">cout &lt;&lt; oct;</span><br></pre></td></tr></table></figure>\n<p>使用cout时，输入控制符hex以十六进制显示，oct以八进制显示<br>在再次切换之前进制进制显示设置一直有效</p>\n<h4 id=\"3-4-类型大小\"><a href=\"#3-4-类型大小\" class=\"headerlink\" title=\"3.4 类型大小\"></a>3.4 类型大小</h4><p>整形</p>\n<ul>\n<li>short 至少16位</li>\n<li>int 至少与short一样长</li>\n<li>long 至少32位，且至少与int一样长</li>\n<li>long long 至少64位，且至少与long long一样长<blockquote>\n<p>在windows下，int与long都位32位<br>long long为64位</p>\n</blockquote>\n</li>\n</ul>\n<p>浮点形</p>\n<ul>\n<li>float 32位，其中1位符号位，8位指数位，23为尾数位</li>\n<li>double 64位，其中1位符号位，11位指数位，52位尾数位<blockquote>\n<p>在C中，使用0.1 + 0.2 &#x3D;&#x3D; 0.3得到的的将是false<br>因为浮点数并不能精确地表示0.1与0.2<br>最后相加的结果不等于0.3的字面量值</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-5-C-数值转换\"><a href=\"#3-5-C-数值转换\" class=\"headerlink\" title=\"3.5 C++数值转换\"></a>3.5 C++数值转换</h4><p>C++转换自动执行的情况</p>\n<ul>\n<li>A类型赋值给B类型时</li>\n<li>同一表达式存在不同类型的值时</li>\n<li>给函数传递参数时</li>\n</ul>\n<p>数值转换时缩窄（narrowing）的情况</p>\n<ul>\n<li>double-&gt;float</li>\n<li>浮点-&gt;整形</li>\n<li>大整形-&gt;小整形</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char a&#123;1234&#125; //不允许</span><br><span class=\"line\">char a = &#123;12&#125; //允许，因为没有缩窄</span><br></pre></td></tr></table></figure>\n<p>使用{}初始化，它会严格检查类型，不允许缩窄的情况</p>\n<p>表达式中的转换<br>可以简单地这样理解：取表达式里最大的类型，将其他类型都转换为此类型</p>\n<p>强制类型转换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(long) a // 为表达式，返回转换为long类型的a值</span><br><span class=\"line\">long (a) // 函数调用版</span><br></pre></td></tr></table></figure>\n<p>同时C++还有更严格的类型转换方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static_cast&lt;int&gt;(a) // 返回a的int类型</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-复合类型\"><a href=\"#4-复合类型\" class=\"headerlink\" title=\"4.复合类型\"></a>4.复合类型</h2><blockquote>\n<p>复合类型，由基本类型构成<br>C++中的复合类型包括<br>数组<br>结构<br>指针<br>类</p>\n</blockquote>\n<h4 id=\"4-1-拼接字符串常量\"><a href=\"#4-1-拼接字符串常量\" class=\"headerlink\" title=\"4.1 拼接字符串常量\"></a>4.1 拼接字符串常量</h4><p>C++中，由空白字符分隔的字符串常量都会被拼接为一个</p>\n<h4 id=\"4-2-读取一整行\"><a href=\"#4-2-读取一整行\" class=\"headerlink\" title=\"4.2 读取一整行\"></a>4.2 读取一整行</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.getline(size, ptr); //读取一整行，并丢弃换行符</span><br><span class=\"line\">cin.get(size, ptr); //读取一整行，并将换行符留在输入流中</span><br></pre></td></tr></table></figure>\n<p>表达式返回cin对象，因此，读取两行可以这样使用<br><code>cin.getline(size, ptr).getline(size, ptr);</code></p>\n<h4 id=\"4-3-string类简介\"><a href=\"#4-3-string类简介\" class=\"headerlink\" title=\"4.3 string类简介\"></a>4.3 string类简介</h4><p>C++98标准新增了string类型<br>对于字符串，string隐去了数组特性，让它更像普通类型<br>下面程序展示了基于string类型的IO方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string fName; //不需要提前指定大小，大小可变</span><br><span class=\"line\">string lName;</span><br><span class=\"line\">string description&#123;&quot;description: &quot;&#125; // 同样也可以初始化;</span><br><span class=\"line\">string container;</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;Enter your first name and last name:&quot; &lt;&lt; endl;</span><br><span class=\"line\">getline(cin, fName), getline(cin, lName);</span><br><span class=\"line\">// cin没有处理string的方法，所以需要额外使用getline</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;Enter your desciption&quot; &lt;&lt; endl;</span><br><span class=\"line\">getline(cin, container);</span><br><span class=\"line\">description += container; // 忽略数组特性，像对象一样操作</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;your name is: &quot; &lt;&lt; fName &lt;&lt; &quot; &quot; &lt;&lt; lName &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; description &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; description[2] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-枚举\"><a href=\"#4-4-枚举\" class=\"headerlink\" title=\"4.4 枚举\"></a>4.4 枚举</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum orientation&#123;west, east, north, south&#125;;</span><br><span class=\"line\">enum &#123;left, right, up, down&#125;;</span><br></pre></td></tr></table></figure>\n<p>一次性定义多个整形常量<br>也可以给枚举取名，限定枚举变量的值</p>\n<h4 id=\"4-5-使用new分配内存\"><a href=\"#4-5-使用new分配内存\" class=\"headerlink\" title=\"4.5 使用new分配内存\"></a>4.5 使用new分配内存</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int * newptr = new int;</span><br><span class=\"line\">int * newarray = new int [10];</span><br><span class=\"line\">int * mallocptr = malloc(sizeof(int));</span><br><span class=\"line\"></span><br><span class=\"line\">delete int;</span><br><span class=\"line\">delete [] int;</span><br><span class=\"line\">free(mallocptr);</span><br></pre></td></tr></table></figure>\n<p>new，是C++提供的新关键字，用于动态分配内存<br>它与malloc的不同点在于</p>\n<ul>\n<li>new分配的是称为“堆”的自由内存，malloc是“栈”内存</li>\n<li>new分配的内存必须用delete释放，malloc需要free</li>\n<li>new分配的数组，必须要用数组形式对应释放</li>\n</ul>\n<h4 id=\"4-6-auto类型的使用方法\"><a href=\"#4-6-auto类型的使用方法\" class=\"headerlink\" title=\"4.6 auto类型的使用方法\"></a>4.6 auto类型的使用方法</h4><p><code>auto container = /*一个指向存放整形数组指针数组的指针*/</code><br>在变量类型复杂时，可以直接用auto代替</p>\n<h4 id=\"4-7-vector与array模板类简介\"><a href=\"#4-7-vector与array模板类简介\" class=\"headerlink\" title=\"4.7 vector与array模板类简介\"></a>4.7 vector与array模板类简介</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; vi(n); // n可以是变量</span><br><span class=\"line\">array&lt;double, n&gt; vd; // n可以是变量</span><br></pre></td></tr></table></figure>\n<p>vector与array提供了动态管理数组的功能，可以代替数组而且更安全<br>可以使用vector与array的类方法来动态分配数组，将在后面提到<br>但是vector相比于数组，处理时间更长一些</p>\n<h2 id=\"5-循环与关系表达式\"><a href=\"#5-循环与关系表达式\" class=\"headerlink\" title=\"5.循环与关系表达式\"></a>5.循环与关系表达式</h2><h4 id=\"5-1-副作用与顺序点\"><a href=\"#5-1-副作用与顺序点\" class=\"headerlink\" title=\"5.1 副作用与顺序点\"></a>5.1 副作用与顺序点</h4><p>顺序点，是程序执行过程中的一个点，进行下一步之前确保对所有副作用都做出了评估<br>在C++中，语句中的分号就是一个顺序点<br>同时，任何完整表达式的最后都是一个顺序点<br>如<code>while (i++ &lt; 5)</code>，i++ &lt; 5是一个完整条件表达式，因为他是while循环的测试条件</p>\n<h4 id=\"5-2-编写延时循环\"><a href=\"#5-2-编写延时循环\" class=\"headerlink\" title=\"5.2 编写延时循环\"></a>5.2 编写延时循环</h4><p>头文件<code>ctime</code>中提供了clock_t类型与CLOCK_PER_SECOND常量<br>目的是为了统一ctime在不同系统上的运行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float seconds;</span><br><span class=\"line\">cout &lt;&lt; &quot;Enter the delay time, in seconds:&quot;;</span><br><span class=\"line\">cin &gt;&gt; seconds;</span><br><span class=\"line\">clock_t delay = seconds * CLOCKS_PER_SEC; // 计算延时的时间戳</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;delaying...&quot; &lt;&lt; endl;</span><br><span class=\"line\">clock_t start = clock();</span><br><span class=\"line\">while (clock() - start &lt; delay); // 这种循环等待的方式实际上会占用电脑大量资源</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;done!&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-基于范围的for循环\"><a href=\"#5-3-基于范围的for循环\" class=\"headerlink\" title=\"5.3 基于范围的for循环\"></a>5.3 基于范围的for循环</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double x[4]&#123;0.1, 5.0, 2.3, 4.2&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (double i : x) // x必须是数组或者容器类型</span><br><span class=\"line\">    cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class=\"line\">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>对于使用for循环遍历容器元素，C++11提供了遍历的新特性</p>\n<h2 id=\"6-输入与输出\"><a href=\"#6-输入与输出\" class=\"headerlink\" title=\"6.输入与输出\"></a>6.输入与输出</h2><h4 id=\"6-1-getchar-与putchar-的代替\"><a href=\"#6-1-getchar-与putchar-的代替\" class=\"headerlink\" title=\"6.1 getchar()与putchar()的代替\"></a>6.1 getchar()与putchar()的代替</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.get();</span><br><span class=\"line\">cin.put(ch);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-cin-get的重载类型\"><a href=\"#6-2-cin-get的重载类型\" class=\"headerlink\" title=\"6.2 cin.get的重载类型\"></a>6.2 cin.get的重载类型</h4><p>cin.get有三种重载类型</p>\n<ul>\n<li><code>ch = cin.get()</code> 不传递任何参数，读取一个字符，返回读取的字符</li>\n<li><code>cin.get(ch)</code> 传递一个char类型参数，读取一个字符，返回cin的引用，可以直接用作判断条件</li>\n<li><code>cin.get(str, size)</code> 传递一个c风格字符串与大小，读取一整行，并将换行符留在输入里，返回cin的引用</li>\n</ul>\n<h4 id=\"6-3-文件尾条件\"><a href=\"#6-3-文件尾条件\" class=\"headerlink\" title=\"6.3 文件尾条件\"></a>6.3 文件尾条件</h4><p>使用文件尾条件作为循环结束条件<br><strong>要判断读取完毕，相比于读特定字符，此方案使用场景更广泛一些</strong></p>\n<p>同时，键盘输入可以通过ctrl + z来模拟文件结尾</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.eof(); // 检测输入流是否到文件结尾</span><br><span class=\"line\">cin.fail(); // 检测是否读取失败(包含读取到文件结尾的情况)</span><br><span class=\"line\">cin.bad(); // 检测读取时是否发生严重错误</span><br><span class=\"line\">cin.good(); // 检测读取状态是否正常</span><br></pre></td></tr></table></figure>\n<p>以上四种cin的方法可以检测cin的读取状态<br>四种状态都是在读取后判断，也就是执行一次读取操作后，再判断状态<br>读取到eof时，eof与fail状态都是1</p>\n<p>同时，可以将cin对象作为一个布尔值使用<br>如<code>if (cin)</code>，这将返回cin的读取状态</p>\n<p>对循环结尾条件的理解<br>流程：先读取-&gt;再判断是否达到结束条件<br><code>while (cin &gt;&gt; temp)</code>与<code>while((ch = cin.get()) != EOF)</code><br>实际上是将“读取”与“判断”的操作合成一句了<br>先从输入流读取，再判断是否读到文件结尾</p>\n<h4 id=\"6-4-将文件作为输入输出流\"><a href=\"#6-4-将文件作为输入输出流\" class=\"headerlink\" title=\"6.4 将文件作为输入输出流\"></a>6.4 将文件作为输入输出流</h4><p>c++提供了fistream&#x2F;fostream类，它给我们提供了文件读取类似cin与cout的接口<br>统一了文件输出输入和标准输入输出流的操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#define IFILE &quot;Avg.in&quot;</span><br><span class=\"line\">#define OFILE &quot;Avg.out&quot;</span><br><span class=\"line\">#define NAMESIZE 1024</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    using std::cout, std::cin, std::endl, std::vector;</span><br><span class=\"line\">    std::ofstream outFile;</span><br><span class=\"line\">    std::ifstream inFile;</span><br><span class=\"line\">    vector&lt;double&gt; data;</span><br><span class=\"line\">    double temp, res = 0.0;</span><br><span class=\"line\"></span><br><span class=\"line\">    outFile.open(OFILE); // cin与cout是单例，但fsteam类可创建多个对象</span><br><span class=\"line\">    inFile.open(IFILE);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!inFile.is_open() || !outFile.is_open()) // is_open方法判断是否打开成功</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Unable to open &quot;</span><br><span class=\"line\">        &lt;&lt; IFILE &lt;&lt; &quot; or &quot;</span><br><span class=\"line\">        &lt;&lt; OFILE &lt;&lt; endl;</span><br><span class=\"line\">        exit(EXIT_FAILURE); // 没有打开成功所以不用关闭</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (inFile &gt;&gt; temp) // 只要还有数据，</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        data.push_back(temp);</span><br><span class=\"line\">        res += temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (inFile.eof()) // 跳出循环，检查状态（读取完成之后发生的）</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (data.size() == 0)</span><br><span class=\"line\">            cout &lt;&lt; &quot;No value readed!&quot; &lt;&lt; endl;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cout &lt;&lt; data.size() &lt;&lt; &quot; value&quot; &lt;&lt; (data.size() &gt; 1 ? &quot;s &quot; : &quot; &quot;) &lt;&lt; &quot;readed&quot; &lt;&lt; endl;</span><br><span class=\"line\">            cout &lt;&lt; &quot;The avg is: &quot; &lt;&lt; res / data.size() &lt;&lt; endl;</span><br><span class=\"line\">            cout &lt;&lt; &quot;Now putting results to &quot; &lt;&lt; OFILE &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 像cin/cout一样使用</span><br><span class=\"line\">            outFile &lt;&lt; data.size() &lt;&lt; &quot; value&quot; &lt;&lt; (data.size() &gt; 1 ? &quot;s &quot; : &quot; &quot;) &lt;&lt; &quot;readed&quot; &lt;&lt; endl;</span><br><span class=\"line\">            outFile &lt;&lt; &quot;The avg is: &quot; &lt;&lt; res / data.size() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">            outFile.close();</span><br><span class=\"line\">            inFile.close();</span><br><span class=\"line\">            exit(EXIT_SUCCESS); // 成功执行</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (inFile.fail())</span><br><span class=\"line\">        cout &lt;&lt; &quot;Type dismatch!&quot; &lt;&lt; endl;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        cout &lt;&lt; &quot;Unknown Error!&quot; &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    outFile.close();</span><br><span class=\"line\">    inFile.close();</span><br><span class=\"line\">    exit(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>补充：exit()与return的区别</strong></p>\n<ul>\n<li>exit与return的级别<ul>\n<li>return是语言级别的，它将控制权交给上一个调用的函数</li>\n<li>exit是系统级别的，它将控制权交给操作系统，返回值也是</li>\n</ul>\n</li>\n<li>exit与return的行为<ul>\n<li>在main函数中，exit与return行为几乎一样</li>\n<li>而在main函数之外，exit能直接将控制权交给系统</li>\n</ul>\n</li>\n<li>最后，在main函数里使用return其实最后也会调用exit函数</li>\n</ul>\n<h2 id=\"7-函数\"><a href=\"#7-函数\" class=\"headerlink\" title=\"7.函数\"></a>7.函数</h2><h4 id=\"7-1-数组参数传递\"><a href=\"#7-1-数组参数传递\" class=\"headerlink\" title=\"7.1 数组参数传递\"></a>7.1 数组参数传递</h4><p>使用数组对函数传参时，必须同时传入数组指针与数组大小</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f_show(const double array[], int n); // 使用const显式指定数组不会被修改</span><br><span class=\"line\">f_modify(double array[], int n); // 使用[]说明array是一个数组</span><br></pre></td></tr></table></figure>\n<p>如果使用容器类vector或者array就不会出现需要传递数组大小的问题<br>直接使用.size()方法获取大小即可</p>\n<h4 id=\"7-2-使用数组区间的函数\"><a href=\"#7-2-使用数组区间的函数\" class=\"headerlink\" title=\"7.2 使用数组区间的函数\"></a>7.2 使用数组区间的函数</h4><p>另一种传递数组范围的方法，是两个指针定义开始与结束的区间<br>通常，结束指针被规定为“超尾”的，指向要处理的末尾值的后一位<br>对于要处理数组区间的函数来说，这个更像是一种语法糖<br>因为不需要通过开始指针和处理个数来指定区间</p>\n<h4 id=\"7-3-常量指针的传递\"><a href=\"#7-3-常量指针的传递\" class=\"headerlink\" title=\"7.3 常量指针的传递\"></a>7.3 常量指针的传递</h4><p>常量指针指向的变量不能被修改，就算变量本身不是常量</p>\n<p>函数参数传递时：<br>const * -&gt; const * (√)<br>* -&gt; const * (√)<br>const * -&gt; * (x)<br>所以声明函数时，尽量在应该使用const指针的地方使用它<br>这样能确保同时兼容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int * array;</span><br><span class=\"line\">int * const array;</span><br></pre></td></tr></table></figure>\n<p>语句一表示，指针指向的是一个const量，不能通过指针修改这个量<br>语句二表示，指针是一个const量，不能修改这个指针指向的地址</p>\n<p>同时，教材还给出了一个很离谱的例子<br>我们来逐步分析下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int **pp2 // 指向常量int的指针的指针</span><br><span class=\"line\">int * pp1; // 指向int的指针</span><br><span class=\"line\">const int n; // 常量int</span><br><span class=\"line\"></span><br><span class=\"line\">pp2 = &amp;pp1; // 可以，将int指针赋值给常量指针</span><br><span class=\"line\">*pp2 = &amp;n; // 可以，常量指针接受常量指针</span><br><span class=\"line\">*pp1 = 10; // pp1不是常量指针，但得到了常量指针的地址，这样就可以用非常量指针修改常量</span><br></pre></td></tr></table></figure>\n<p>因此，在使用指向指针的指针时，一般不使用const</p>\n<h4 id=\"7-4-二维数组传参\"><a href=\"#7-4-二维数组传参\" class=\"headerlink\" title=\"7.4 二维数组传参\"></a>7.4 二维数组传参</h4><p>首先区分一下定义<br>(注：[]的优先级要高于*)</p>\n<ul>\n<li><code>* a[3]</code> 大小为3的数组，数组里存了指针</li>\n<li><code>(*a)[3]</code> 指针，指向大小为3的数组</li>\n<li><code>a[][3]</code> 同上面的</li>\n<li><code>(*a)[i]</code> 指针，指向变长数组</li>\n</ul>\n<h4 id=\"7-5-auto与typedef对类型的简化\"><a href=\"#7-5-auto与typedef对类型的简化\" class=\"headerlink\" title=\"7.5 auto与typedef对类型的简化\"></a>7.5 auto与typedef对类型的简化</h4><p>当一个类型特别复杂时，可以使用typedef来定义，之后每一次引用typedef即可<br>同时也可以使用auto类型，来自动判断</p>\n<h2 id=\"8-函数进阶\"><a href=\"#8-函数进阶\" class=\"headerlink\" title=\"8.函数进阶\"></a>8.函数进阶</h2><h4 id=\"8-1-C-内联函数\"><a href=\"#8-1-C-内联函数\" class=\"headerlink\" title=\"8.1 C++内联函数\"></a>8.1 C++内联函数</h4><p>适用情况：函数本身代码执行时间很短，但需执行多次的情况<br>它的适用范围和#define的宏定义函数很像，但前者行为更像一个函数，功能更强大<br><code>inline int add(int a, int b)</code>内联函数的例子<br>注：内联函数无法递归，但既然你都内联了，为啥还要递归</p>\n<h4 id=\"8-2-引用变量\"><a href=\"#8-2-引用变量\" class=\"headerlink\" title=\"8.2 引用变量\"></a>8.2 引用变量</h4><p>引用除了隐式使用指针的功能外，还有其他特性</p>\n<ul>\n<li>引用必须在声明时赋值，且引用完不能更改引用的指向<ul>\n<li><code>int &amp; num = a;</code> 相当于 <code>int * const num = &amp;a;</code></li>\n</ul>\n</li>\n<li>引用创建的对象，其功能和变量原型一样，只不过换了名字<ul>\n<li>例如<code>int &amp; num = a;</code>然后<code>&amp;num</code>，&amp;num效果与&amp;a相同</li>\n</ul>\n</li>\n</ul>\n<p>引用变量在函数参数传递当中的应用</p>\n<ul>\n<li>和传递指针的行为类似<ul>\n<li>只不过省去了传参时求地址和使用时解引用的操作</li>\n</ul>\n</li>\n<li>在传递大规模数据时<ul>\n<li>使用<code>const int &amp; num = a</code>来定义常量引用</li>\n<li>再给函数传递参数时，能够保证大数据不被再拷贝一遍，也能保证源数据不被修改</li>\n</ul>\n</li>\n</ul>\n<p>注意：引用在参数传递时，更多的是针对结构或者类给函数传参的情况</p>\n<h4 id=\"8-3-在函数中使用引用\"><a href=\"#8-3-在函数中使用引用\" class=\"headerlink\" title=\"8.3 在函数中使用引用\"></a>8.3 在函数中使用引用</h4><p><code>const ob &amp; accumulate(ob &amp; a, const ob &amp; b)</code><br>该函数声明：</p>\n<ul>\n<li>传递一个ob类型的引用a，可修改</li>\n<li>传递一个ob类型的引用b，不可修改</li>\n<li>返回一个ob类型的引用，且该引用不可当作赋值符号左值<ul>\n<li>例如<code>accumulate(a, b) = c</code>，若返回值不是const类型，则返回对象会被修改为c的值</li>\n</ul>\n</li>\n</ul>\n<p>同时，不能将函数内的变量当作引用返回，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ob &amp; foo(ob &amp; a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ob b;</span><br><span class=\"line\">    return b; // 错误的，因为离开函数b就会消失</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确的做法是将参数中的引用返回</p>\n<h4 id=\"8-4-对象、继承与引用\"><a href=\"#8-4-对象、继承与引用\" class=\"headerlink\" title=\"8.4 对象、继承与引用\"></a>8.4 对象、继承与引用</h4><h4 id=\"8-5-补充：cout输出格式\"><a href=\"#8-5-补充：cout输出格式\" class=\"headerlink\" title=\"8.5 补充：cout输出格式\"></a>8.5 补充：cout输出格式</h4><p>格式个鸡毛！要格式用printf，方便得多效率还高</p>\n","text":"0.目录1.预备知识C++在C上的提升 保留了C过程性语言的特性 面向对象编程(OOP) 泛型编程 1.1 C语言C语言 是高级语言 它致力于解决问题，而不针对...","permalink":"/post/C-教程","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"tutorial","slug":"tutorial","count":2,"path":"api/categories/tutorial.json"}],"tags":[{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0-%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">0.目录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">1.预备知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-C%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">1.1 C语言</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">1.2 面向过程编程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">1.3 面向对象编程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-%E8%BF%87%E7%A8%8B%E5%88%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83\"><span class=\"toc-text\">1.4 过程到对象的思考</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-5-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">1.5 泛型编程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-6-%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E4%B8%8E%E6%A0%87%E5%87%86\"><span class=\"toc-text\">1.6 可移植性与标准</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-7-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">1.7 编译过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-x-%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">1.x 补充</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C\"><span class=\"toc-text\">2.开始学习C++</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%88%86%E5%8F%B7\"><span class=\"toc-text\">2.1 语句和分号</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-C%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E4%BA%8EC-%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">2.2 C语言注释于C++语言注释</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-C-%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">2.3 C++的头文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">2.4 名称空间</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">2.5 运算符重载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-n%E4%B8%8Eendl%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2.6 \\n与endl的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-7-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">2.7 赋值运算符</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-8-%E7%B1%BB%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">2.8 类简介</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-9-main%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8E%BB%E5%93%AA%E4%BA%86%EF%BC%9F\"><span class=\"toc-text\">2.9 main的返回值去哪了？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3.变量类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-sizeof%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">3.1 sizeof的使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3.2 大括号初始化方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-%E6%95%B4%E5%BD%A2%E5%B8%B8%E9%87%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3.3 整形常量的三种表示方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">3.4 类型大小</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-C-%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">3.5 C++数值转换</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">4.复合类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">4.1 拼接字符串常量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E8%AF%BB%E5%8F%96%E4%B8%80%E6%95%B4%E8%A1%8C\"><span class=\"toc-text\">4.2 读取一整行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-string%E7%B1%BB%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">4.3 string类简介</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">4.4 枚举</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-5-%E4%BD%BF%E7%94%A8new%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98\"><span class=\"toc-text\">4.5 使用new分配内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-6-auto%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.6 auto类型的使用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-7-vector%E4%B8%8Earray%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">4.7 vector与array模板类简介</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">5.循环与关系表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E5%89%AF%E4%BD%9C%E7%94%A8%E4%B8%8E%E9%A1%BA%E5%BA%8F%E7%82%B9\"><span class=\"toc-text\">5.1 副作用与顺序点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-%E7%BC%96%E5%86%99%E5%BB%B6%E6%97%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">5.2 编写延时循环</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-3-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">5.3 基于范围的for循环</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">6.输入与输出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-getchar-%E4%B8%8Eputchar-%E7%9A%84%E4%BB%A3%E6%9B%BF\"><span class=\"toc-text\">6.1 getchar()与putchar()的代替</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-cin-get%E7%9A%84%E9%87%8D%E8%BD%BD%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">6.2 cin.get的重载类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-3-%E6%96%87%E4%BB%B6%E5%B0%BE%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">6.3 文件尾条件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-4-%E5%B0%86%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81\"><span class=\"toc-text\">6.4 将文件作为输入输出流</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">7.函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-1-%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">7.1 数组参数传递</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-2-%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">7.2 使用数组区间的函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-3-%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">7.3 常量指针的传递</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82\"><span class=\"toc-text\">7.4 二维数组传参</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-5-auto%E4%B8%8Etypedef%E5%AF%B9%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8C%96\"><span class=\"toc-text\">7.5 auto与typedef对类型的简化</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">8.函数进阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-1-C-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">8.1 C++内联函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-2-%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">8.2 引用变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-3-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">8.3 在函数中使用引用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-4-%E5%AF%B9%E8%B1%A1%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">8.4 对象、继承与引用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-5-%E8%A1%A5%E5%85%85%EF%BC%9Acout%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">8.5 补充：cout输出格式</span></a></li></ol></li></ol></li></ol>","author":{"name":"猫冰","slug":"blog-author","avatar":"/images/MB-drinking.png","link":"/","description":"小猫用来存博客的地方（也会发一点有趣的东西）","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":"https://github.com/C0P1Fur","twitter":"https://x.com/_Caticee","customs":{"bilibili":{"icon":"/images/bilibili.svg","link":"https://space.bilibili.com/2140016240"}}}}},"mapped":true,"hidden":false,"prev_post":{"title":"P1059","uid":"aaa8957324fc6270d3aee88df4360ef5","slug":"P1059","date":"2025-10-28T11:58:09.000Z","updated":"2025-10-28T12:17:50.697Z","comments":true,"path":"api/articles/P1059.json","keywords":"Catice, 猫冰","cover":null,"text":"题目描述明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N 个 1 到 1000 之间的随机整数 (N≤100)，对于其中重复...","permalink":"/post/P1059","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"algorithm","slug":"algorithm","count":2,"path":"api/categories/algorithm.json"},{"name":"sort","slug":"algorithm/sort","count":1,"path":"api/categories/algorithm/sort.json"}],"tags":[{"name":"notes","slug":"notes","count":1,"path":"api/tags/notes.json"}],"author":{"name":"猫冰","slug":"blog-author","avatar":"/images/MB-drinking.png","link":"/","description":"小猫用来存博客的地方（也会发一点有趣的东西）","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":"https://github.com/C0P1Fur","twitter":"https://x.com/_Caticee","customs":{"bilibili":{"icon":"/images/bilibili.svg","link":"https://space.bilibili.com/2140016240"}}}}}},"next_post":{"title":"WinUI3教程","uid":"0beed5709ac36fd358d79f96dd27d6a4","slug":"WinUI3教程","date":"2025-10-23T11:34:07.000Z","updated":"2025-10-24T05:05:15.113Z","comments":true,"path":"api/articles/WinUI3教程.json","keywords":"Catice, 猫冰","cover":null,"text":"0.前置知识 GUI 即Graphic User Interface，它提供用户友好的图像操作界面 CLI 即Command-Line Interface，命令...","permalink":"/post/WinUI3教程","photos":[],"count_time":{"symbolsCount":408,"symbolsTime":"1 mins."},"categories":[{"name":"tutorial","slug":"tutorial","count":2,"path":"api/categories/tutorial.json"}],"tags":[{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"},{"name":"GUI-Development","slug":"GUI-Development","count":1,"path":"api/tags/GUI-Development.json"}],"author":{"name":"猫冰","slug":"blog-author","avatar":"/images/MB-drinking.png","link":"/","description":"小猫用来存博客的地方（也会发一点有趣的东西）","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":"https://github.com/C0P1Fur","twitter":"https://x.com/_Caticee","customs":{"bilibili":{"icon":"/images/bilibili.svg","link":"https://space.bilibili.com/2140016240"}}}}}}}