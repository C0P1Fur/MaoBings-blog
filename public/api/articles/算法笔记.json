{"title":"算法笔记","uid":"f953a678ee781dfc0167a1b2b1c56f02","slug":"算法笔记","date":"2025-10-22T12:35:39.000Z","updated":"2025-10-22T12:38:27.620Z","comments":true,"path":"api/articles/算法笔记.json","keywords":"Catice, 猫冰","cover":null,"content":"<h2 id=\"0-本节课内容列表\"><a href=\"#0-本节课内容列表\" class=\"headerlink\" title=\"0.本节课内容列表\"></a>0.本节课内容列表</h2><ul>\n<li>排序<ul>\n<li>快速排序</li>\n<li>归并排序</li>\n</ul>\n</li>\n<li>二分<ul>\n<li>整数二分</li>\n<li>浮点数二分</li>\n</ul>\n</li>\n</ul>\n<p>课时要做的</p>\n<ul>\n<li>理解算法思想<br>课后要做的</li>\n<li>理解并且背（快速默写模板）</li>\n<li>默写，用题来练默写</li>\n<li>重复默写模板</li>\n</ul>\n<h2 id=\"1-排序\"><a href=\"#1-排序\" class=\"headerlink\" title=\"1.排序\"></a>1.排序</h2><h4 id=\"1-1快速排序\"><a href=\"#1-1快速排序\" class=\"headerlink\" title=\"1.1快速排序\"></a>1.1快速排序</h4><p>性质：平均时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2)</p>\n<p>主要思想</p>\n<ul>\n<li>最核心的思路：分而治之，将大问题分成一个个小问题</li>\n<li>具体实现<ul>\n<li>定义一个左边界和右边界，圈出范围</li>\n<li>在范围里随机取数，一般取中间的，设为x</li>\n<li>将小于x的数排在x左边，大于的排在右边</li>\n<li>此时范围被分为两部分：左半小，右半大</li>\n<li>继续对左半与右半执行一遍这个过程</li>\n</ul>\n</li>\n</ul>\n<p>代码范例，最核心的代码段是quick_sort</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const int N = 1e6 + 10; // + 10防止数组越界，是一种缓冲区</span><br><span class=\"line\">int n;</span><br><span class=\"line\">int a[N];</span><br><span class=\"line\"></span><br><span class=\"line\">void quick_sort(int * a, int l, int r) //l表示left，r表示right</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (l &gt;= r) return;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * l + r &gt;&gt; 1表达式与(l + r) / 2效果一样</span><br><span class=\"line\">    * 但是更快而且更简便</span><br><span class=\"line\">    * </span><br><span class=\"line\">    * l + r &gt;&gt; 1默认是向下取整</span><br><span class=\"line\">    * 使用 l + r + 1 &gt;&gt; 1可以向上取整</span><br><span class=\"line\">    * </span><br><span class=\"line\">    * 同时，将x去中间的一个数可以避免死循环</span><br><span class=\"line\">    */</span><br><span class=\"line\">    int x = a[l + r &gt;&gt; 1], i = l - 1, j = r + 1;</span><br><span class=\"line\">    while (i &lt; j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        do i++; while (a[i] &lt; x);</span><br><span class=\"line\">        do j--; while (a[j] &gt; x);</span><br><span class=\"line\">        if (i &lt; j) swap(a[i], a[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * 这里要么写l, j 要么写l，i - 1</span><br><span class=\"line\">    * 因为最后要将数组一分为二</span><br><span class=\"line\">    * i 与 j的大小就有两种情况</span><br><span class=\"line\">    * - i == j，此时两种方法的效果是一样的</span><br><span class=\"line\">    * - j &lt; i，此时j指向数组的左半部分，就不能向左偏移了，i同理</span><br><span class=\"line\">    */</span><br><span class=\"line\">    quick_sort(a, l, j);</span><br><span class=\"line\">    quick_sort(a, j + 1, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    scanf(&quot;%d&quot;, &amp;n); //用scanf读取数据比cin要快一点</span><br><span class=\"line\">    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    quick_sort(a, 0, n - 1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, a[i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-2-归并排序\"><a href=\"#1-2-归并排序\" class=\"headerlink\" title=\"1.2 归并排序\"></a>1.2 归并排序</h4><p>性质：时间复杂度稳定为nlogn</p>\n<p>思想</p>\n<ul>\n<li>将数组不断划分，分为很小的部分</li>\n<li>对小部分进行排序，这下我们得到了两个顺序数组</li>\n<li>将两个小部分合成，又得到了新的顺序数组</li>\n<li>不断合成，最后结果为原来的大数组</li>\n</ul>\n<p>代码实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void merge_sort(int * a, int l, int r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (l &gt;= r) return;</span><br><span class=\"line\">    int mid = l + r &gt;&gt; 1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 切分操作</span><br><span class=\"line\">    merge_sort(a, l, mid), merge_sort(a, mid + 1, r);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //排序操作</span><br><span class=\"line\">    int k = 0, i = l, j = mid + 1;</span><br><span class=\"line\">    while (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (a[i] &lt;= a[j]) t[k++] = a[i++];</span><br><span class=\"line\">        else t[k++] = a[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while (i &lt;= mid) t[k++] = a[i++];</span><br><span class=\"line\">    while (j &lt;= r) t[k++] = a[j++];</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (i = 0, j = l; j &lt;= r; i++, j++) a[j] = t[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-二分\"><a href=\"#2-二分\" class=\"headerlink\" title=\"2.二分\"></a>2.二分</h2><h4 id=\"2-1-整数二分\"><a href=\"#2-1-整数二分\" class=\"headerlink\" title=\"2.1 整数二分\"></a>2.1 整数二分</h4><p>有单调性一定可以二分，二分不一定需要单调性<br>二分思想的本质</p>\n<ul>\n<li>现有一数组，有一值，在数组里找值</li>\n<li>通过对数组中点性质的比较，可以缩小值的范围</li>\n<li>不断缩小，最后精确找到值</li>\n</ul>\n<p>代码实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 最终结果：l == r，指向答案</span><br><span class=\"line\">// 特点：这种模板不存在找不到的情况，找不到需要按照题意单独判断</span><br><span class=\"line\">// 特点：一定可以把符合性质的范围二分出来</span><br><span class=\"line\">// 选择：当check为true使，右边界收缩时，就用第一种，反之第二种</span><br><span class=\"line\">int bsearch1(int l, int r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (l &lt; r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mid = l + r &gt;&gt; 1;</span><br><span class=\"line\">        if (check()) r = mid;</span><br><span class=\"line\">        else l = mid + 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int bsearch2(int l, int r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (l &lt; r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mid = l + r + 1 &gt;&gt; 1;</span><br><span class=\"line\">        if (check()) l = mid;</span><br><span class=\"line\">        else r = mid - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2浮点数二分\"><a href=\"#2-2浮点数二分\" class=\"headerlink\" title=\"2.2浮点数二分\"></a>2.2浮点数二分</h4><p>和整数二分类似，只不过<strong>不用考虑向下或是向上取整问题</strong><br>代码实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double bsearch_3(double l, double r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求</span><br><span class=\"line\">    while (r - l &gt; eps)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        double mid = (l + r) / 2;</span><br><span class=\"line\">        if (check(mid)) r = mid;</span><br><span class=\"line\">        else l = mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return l; //返回l或者r的一个</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","feature":true,"text":"0.本节课内容列表 排序 快速排序 归并排序 二分 整数二分 浮点数二分 课时要做的 理解算法思想课后要做的 理解并且背（快速默写模板） 默写，用题来练默写 重...","permalink":"/post/算法笔记","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"algorithm","slug":"algorithm","count":1,"path":"api/categories/algorithm.json"}],"tags":[{"name":"note","slug":"note","count":1,"path":"api/tags/note.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0-%E6%9C%AC%E8%8A%82%E8%AF%BE%E5%86%85%E5%AE%B9%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">0.本节课内容列表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">1.排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">1.1快速排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">1.2 归并排序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">2.二分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">2.1 整数二分</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">2.2浮点数二分</span></a></li></ol></li></ol></li></ol>","author":{"name":"猫冰","slug":"blog-author","avatar":"/images/MB-drinking.png","link":"/","description":"小猫用来存博客的地方（也会发一点有趣的东西）","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":"https://github.com/C0P1Fur","twitter":"https://x.com/_Caticee","customs":{"bilibili":{"icon":"/images/bilibili.svg","link":"https://space.bilibili.com/2140016240"}}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"git分支部分教程","uid":"326c974c2dd33a5c1c93eb6f0ddf6329","slug":"git教程","date":"2025-10-16T14:46:06.000Z","updated":"2025-10-22T12:39:26.736Z","comments":true,"path":"api/articles/git教程.json","keywords":"Catice, 猫冰","cover":null,"text":" 得先说明，这些东西都是写给我自己看的用于梳理自己的思路，以及之后复习用所以某些地方写的不是很清楚 0.git分支特性简介git的分支模型具有轻量的特点，支持在...","permalink":"/post/git教程","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"git","slug":"git","count":1,"path":"api/categories/git.json"}],"tags":[{"name":"tutorial","slug":"tutorial","count":2,"path":"api/tags/tutorial.json"}],"author":{"name":"猫冰","slug":"blog-author","avatar":"/images/MB-drinking.png","link":"/","description":"小猫用来存博客的地方（也会发一点有趣的东西）","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":"https://github.com/C0P1Fur","twitter":"https://x.com/_Caticee","customs":{"bilibili":{"icon":"/images/bilibili.svg","link":"https://space.bilibili.com/2140016240"}}}}},"feature":true}}