[{"id":"06a43fe365ef05a958ca95b02c98495b","title":"探寻C++输入输出的最佳方案","content":"0.前言看大佬题解时总是会提到关于输入输出的问题，那就是：cstdio的输入输出函数(scanf, printf)，总比iostream的输入输出函数快\n1.输出实验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 传统标准&amp;文件输出：printf&amp;fprintf * C++标准&amp;文件输出：ostream&amp;ofstream*/#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &quot;files.hpp&quot;clock_t cTest(FILE * out);clock_t cppTest(std::ostream &amp; out);int main(void)&#123;    // C风格标准&amp;文件输出    FILE * cStandard = stdout;    FILE * cFile = fopen(OFILE, &quot;w&quot;);    // CPP风格标准&amp;文件输出    std::ostream &amp; cppStandard = std::cout;    std::ofstream cppFile;    cppFile.open(OFILE);    clock_t tcS, tcF, tcppS, tcppF;    // 是否打开成功判断    if (cFile == NULL || !cppFile.is_open())        exit(EXIT_FAILURE);    tcS = cTest(cStandard); // C标准输出用掉的时间    tcF = cTest(cFile); // C文件输出    tcppS = cppTest(cppStandard); // CPP标准输出    tcppF = cppTest(cppFile); // CPP文件输出    std::cout &lt;&lt; &quot;---&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;c standard: &quot; &lt;&lt; double(tcS) / CLOCKS_PER_SEC &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;c file: &quot; &lt;&lt; double(tcF) / CLOCKS_PER_SEC &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;cpp standard: &quot; &lt;&lt; double(tcppS) / CLOCKS_PER_SEC &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;cpp file: &quot; &lt;&lt; double(tcppF) / CLOCKS_PER_SEC &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;        fclose(cFile);    cppFile.close();&#125;clock_t cTest(FILE * out)&#123;    clock_t start, end;    start = clock();    for (int i = 0; i &lt; ITERATE; i++)        fprintf(out, &quot;%s\\n&quot;, QUOTE);    end = clock();    return end - start;&#125;clock_t cppTest(std::ostream &amp; out)&#123;    clock_t start, end;    start = clock();    for (int i = 0; i &lt; ITERATE; i++)        out &lt;&lt; QUOTE &lt;&lt; std::endl;    end = clock();    return end - start;&#125;\n\n最后输出：\n1234c standard: 27.648 secondsc file: 0.029 secondscpp standard: 3.726 secondscpp file: 0.154 seconds\n\n结论：\n\n对于标准输出与文件输出，文件输出 远优于 标准输出\n对于c文件输出与cpp文件输出，c文件输出 优于 cpp文件输出\n对于c标准输出与cpp标准输出，cpp标准输出 远优于 c标准输出\n\n但做到这里我意识到，大数据一般不会写入标准输出里因此比较的对象应该是重定向输出与文件输出又进行了一次实验，这次的结果将重定向到CONTAINER.dat里结果\n1234c standard: 0.046 secondsc file: 0.033 secondscpp standard: 0.181 secondscpp file: 0.151 seconds\n\n于是最后得出结论\n\n对于重定向输出与文件输出，文件输出 远优于 重定向输出\n对于文件输出，c文件输出 优于 cpp文件输出\n对于重定向输出，c重定向输出 优于 cpp重定向输出\n\n2.输入实验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 传统标准&amp;文件输入：scanf&amp;fscanff * C++标准&amp;文件输出：istream&amp;ifstream*/#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &quot;files.hpp&quot;clock_t cTest(FILE * in);clock_t cppTest(std::istream &amp; in);int main(void)&#123;    // c标准&amp;文件输入    FILE * ciFile = fopen(IFILE, &quot;r&quot;);    FILE * ciStandard = stdin;    // cpp标准&amp;文件输入    std::ifstream cppiFile;    cppiFile.open(IFILE);    std::istream &amp; cppiStandard = std::cin;    clock_t tcF, tcS, tcppF, tcppS;    if (ciFile == NULL || !cppiFile.is_open())        exit(EXIT_FAILURE);        tcF = cTest(ciFile);    tcS = cTest(ciStandard);    tcppF = cppTest(cppiFile);    tcppS = cppTest(cppiStandard);    std::cout &lt;&lt; &quot;---&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;c standard: &quot; &lt;&lt; double(tcS) / CLOCKS_PER_SEC &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;c file: &quot; &lt;&lt; double(tcF) / CLOCKS_PER_SEC &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;cpp standard: &quot; &lt;&lt; double(tcppS) / CLOCKS_PER_SEC &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;cpp file: &quot; &lt;&lt; double(tcppF) / CLOCKS_PER_SEC &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;    fclose(ciFile);    cppiFile.close();&#125;clock_t cTest(FILE * in)&#123;    clock_t start, end;    char buff[1024];        start = clock();    for (int i = 0; i &lt; ITERATE; i++)        fscanf(in, &quot;%s&quot;, buff);    end = clock();    return end - start;&#125;clock_t cppTest(std::istream &amp; in)&#123;    clock_t start, end;    char buff[1024];    start = clock();    for (int i = 0; i &lt; ITERATE; i++)        std::cin &gt;&gt; buff;    end = clock();    return end - start;&#125;\n\n输出结果:\n1234c standard: 0.02 secondsc file: 0.026 secondscpp standard: 0.039 secondscpp file: 0.043 seconds\n\n结论：\n\n对于重定向输入与文件输入，文件输入 约等于 重定向输入\n对于文件输入，c文件输入 优于 cpp文件输入\n对于重定向输入，c重定向输入 优于 cpp重定向输入\n\n3.结论c的输入输出效率确实比cpp的快一些同时，使用文件输入输出的效率是所有情况最快的\n这个结论有什么用呢？我们针对算法竞赛来分析\n算法竞赛的数据输入输出分为两种类型：\n\n核心代码模式\n线上算法平台（如leetcode）评判的模式\n特点：不需要些输入输出的部分，只需要实现核心代码\n\n\nACM模式\n目前主流的模式\n特点：需要考虑数据的输入与输出，评判标准是输出是否一致所以我们针对对ACM模式进行讨论ACM模式流程：给定输入文件-&gt;输入到程序-&gt;得到输出文件-&gt;对比标准答案显然这是一个重定向的过程于是，对于竞赛来说，确实是使用c的输入输出模式，会节省一些时间\n\n\n\n","slug":"探寻C-输入输出的最佳方案","date":"2025-11-08T05:32:37.000Z","categories_index":"","tags_index":"C++,io","author_index":"猫冰"},{"id":"aaa8957324fc6270d3aee88df4360ef5","title":"P1059","content":"题目描述明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N 个 1 到 1000 之间的随机整数 (N≤100)，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。\n输入格式输入有两行，第 1 行为 1 个正整数，表示所生成的随机数的个数 N。\n第 2 行有 N 个用空格隔开的正整数，为所产生的随机数。\n输出格式输出也是两行，第 1 行为 1 个正整数 M，表示不相同的随机数的个数。\n第 2 行为 M 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;const int N = 110;int a[N];int n;void quick_sort(int l, int r)&#123;    if (l &gt;= r) return;    int x = a[l + r &gt;&gt; 1], i = l - 1, j = r + 1;    while (i &lt; j)    &#123;        do i++; while(a[i] &lt; x);        do j--; while(a[j] &gt; x);        if (i &lt; j) swap(a[i], a[j]);    &#125;    quick_sort(l, j), quick_sort(j + 1, r);&#125;int main(void)&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);    quick_sort(0, n - 1);    int count = 1;    for (int p1 = 0, p2 = 1; p2 &lt; n; p2++)    &#123;        if (a[p1] &lt; a[p2])        &#123;            p1++;            a[p1] = a[p2];            count++;        &#125;    &#125;    cout &lt;&lt; count &lt;&lt; endl;    for (int i = 0; i &lt; count; i++)        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;&#125;\n\n总结我对for循环的理解for (1; 2; 3)\n对于2边界条件的思考\n\n代码块被执行时，判断条件都是满足的\n如for( ; i &lt; n; )，在整个for循环代码块的执行过程中，i都是小于n的\n\n\n最后变量的状态是，变量最后一次执行的状态 + 3中修改的状态\n如for ( ; i &lt; n; i++)，最后i的状态是，i &#x3D; n - 1，最后再 ++1\n\n\n\n双指针去重算法记住有这种线性的去重算法，前提是数组是有序的核心概念就是把不重复的元素都放在数组前面去这一个操作需要两个定位点，也就是前指针和后指针，才能完成这个交换操作类似的思想还有快速排序中的交换\n","slug":"P1059","date":"2025-10-28T11:58:09.000Z","categories_index":"algorithm,sort","tags_index":"notes","author_index":"猫冰"},{"id":"84dd61f8b313822c2cc9ae03433e502e","title":"C++教程","content":"0.目录1.预备知识C++在C上的提升\n\n保留了C过程性语言的特性\n面向对象编程(OOP)\n泛型编程\n\n1.1 C语言C语言\n\n是高级语言\n它致力于解决问题，而不针对特定的硬件（C语言可移植的原因）\n将低级语言的效率、硬件访问能力和高级语言的通用性可移植性结合\n\n\n\n1.2 面向过程编程面向过程编程的核心思想\n\n最关心的是如何解决问题\n自上而下地去拆分问题，找到解决方案\n\n\n关注的是，面对问题，如何“一步一步做”才能解决。\n\n1.3 面向对象编程面向对象编程的核心思想\n\n最关心的是解决问题需要的对象\n自下而上，先构建蓝图，再去解决问题\n\n\n编程时，不再首先关注“一步一步怎么做”，而是先思考“这个程序里涉及到哪些事物”，然后为这些事务创建“模板”（类），最后再通过模板生成具体的“实例”（对象）来协同工作。最后才解决问题。\n\n1.4 过程到对象的思考由过程到面向对象语言的发展，是问题规模扩大之后的必然因为随着问题规模扩大\n\n面向过程语言\n必然需要越来越多针对性的方法去解决问题\n程序变得越来越臃肿，不可维护\n\n\n面向对象语言\n不需要提供针对性的解决方案，只是从现有的类出发去解决问题\n程序能够灵活应对问题，维护性强\n\n\n\n我对于C引进类于新动态分配内存关键字的看法：它们是一个组合拳，类的引进使得动态内存的管理变得更方便，有条理。而动态内存又让程序更加灵活。还有泛型编程更是增加了这种灵活度。\n1.5 泛型编程简化代码的编程模式强调对不同的数据类型只用一个函数处理\n1.6 可移植性与标准标准的制定，保证了C语言的可移植性\n\nC++98，为1998年通过的C++标准\nC++03，2003的标准第二版，修订了错误，但没有改变语法（因此我们使用C++98表示这两个版本）\nC++11，2011通过的标准，新增了众多特性\n\n1.7 编译过程比较熟悉，跳过了\n1.x 补充小知识\n\nC++是C的超集，任何C程序都可以在C++环境中运行\nC++中的++来源于C语言的递增运算符++\nC++集成了C的低级硬件访问与OOP高级抽象概念\nC++的源代码文件有多种扩展名（不只有cpp一种），具体取决于系统\n\n2.开始学习C++\n只记录我C语言没学过或者忘记的知识\n\n2.1 语句和分号在C中，分号不是语句之间的标识，而是一个语句的组成部分，没有分号，语句就不完整\n补充:C语言中的语句类型\n\n表达式语句\n包含赋值表达式，函数表达式\n\n\n控制语句\n条件判断，循环，跳转语句\n\n\n复合语句\n大括号括起来的\n\n\n空语句\n单独的一个分号会被视为一个空语句\n\n\n声明语句\n声明变量的语句\n\n\n\n补充:C语言中的表达式类型\n\n算数表达式（返回计算结果）\n算数运算符计算数值\n\n\n关系表达式（返回布尔类型）\n比较两个数值之间的关系\n\n\n逻辑表达式（返回布尔类型）\n逻辑运算符连接的关系表达式\n\n\n赋值表达式（返回赋值结果）\n将一个值赋给一个变量\n\n\n条件表达式（返回符合条件的值）\n逗号表达式（返回最后一个表达式的值）\n从左向右执行表达式\n\n\n函数调用表达式（函数必须要有返回值）\n\n2.2 C语言注释于C++语言注释\n//，C++的注释风格\n/**/，C的注释风格所以实际上，C并不是最开始就能兼容//的，直到C99标准才把它添加进去使用C++注释风格更好一点，能避免问题\n\n2.3 C++的头文件\nC++头文件：无拓展名\nC头文件：以.h结尾为了C++有兼容C的库，一般在头文件前添加’c’并去掉’.h’，如’cmath’没有’.h’结尾的头文件，默认都是有名称空间的，这是C++的特性\n\n2.4 名称空间相当于一个包裹，将代码打包，当日后要用到包裹中的函数时，就要指定包裹避免名称冲突\n\nusing namespace xxx; 是一个偷懒的做法，它为方便这个特性之前出现的项目提供，这样就不需要对为适应C++对代码进行过多修改\n\n12using namespace xxx; //引入整个名称空间using namespace xxx:yyy; //引入名称空间里的某个项\n\n2.5 运算符重载即同一个运算符可以有不同的含义，这个含义由上下文确定C++的特性使我们能够定义这些运算符的操作\n重载这个词，在泛型编程里也经常被提到，我的理解是：对于同一个符号，在不同的情况下，会做出不同的反应\n2.6 \\n与endl的区别endl能够保证刷新输出，而\\n不能保证\n2.7 赋值运算符C与C++都有这个特性，也就是赋值运算符能够连续使用a = b = c //合法的赋值将从右向左进行\n2.8 类简介类是蓝图，而对象则是按照蓝图做的实体类之于对象，就像类型之于变量\n而不同的是，类型是内置于C++中，作为语言的一部分的而类则是由用户定义的\n2.9 main的返回值去哪了？将操作系统看为调用main函数的对象，main函数的返回值最后回到了操作系统实际上，main返回0值，代表程序成功运行，非0值则表示不成功\n3.变量类型3.1 sizeof的使用对于类型名，sizeof必须要加括号对于变量名，sizeof的括号是可选的\n3.2 大括号初始化方式12int var1&#123;5&#125;;int var2 = &#123;6&#125;;\n以上是大括号初始化器的两种使用方法，等号是可选的同时，空大括号将变量初始化为0\n3.3 整形常量的三种表示方式123int var1 = 123;int var2 = 0123;int var3 = 0x123;\n整形常量，以1开头表示十进制，以0开头表示八进制，以0x开头表示十六进制\n12cout &lt;&lt; hex;cout &lt;&lt; oct;\n使用cout时，输入控制符hex以十六进制显示，oct以八进制显示在再次切换之前进制进制显示设置一直有效\n3.4 类型大小整形\n\nshort 至少16位\nint 至少与short一样长\nlong 至少32位，且至少与int一样长\nlong long 至少64位，且至少与long long一样长\n在windows下，int与long都位32位long long为64位\n\n\n\n浮点形\n\nfloat 32位，其中1位符号位，8位指数位，23为尾数位\ndouble 64位，其中1位符号位，11位指数位，52位尾数位\n在C中，使用0.1 + 0.2 &#x3D;&#x3D; 0.3得到的的将是false因为浮点数并不能精确地表示0.1与0.2最后相加的结果不等于0.3的字面量值\n\n\n\n3.5 C++数值转换C++转换自动执行的情况\n\nA类型赋值给B类型时\n同一表达式存在不同类型的值时\n给函数传递参数时\n\n数值转换时缩窄（narrowing）的情况\n\ndouble-&gt;float\n浮点-&gt;整形\n大整形-&gt;小整形\n\n12char a&#123;1234&#125; //不允许char a = &#123;12&#125; //允许，因为没有缩窄\n使用{}初始化，它会严格检查类型，不允许缩窄的情况\n表达式中的转换可以简单地这样理解：取表达式里最大的类型，将其他类型都转换为此类型\n强制类型转换\n12(long) a // 为表达式，返回转换为long类型的a值long (a) // 函数调用版\n同时C++还有更严格的类型转换方法\n1static_cast&lt;int&gt;(a) // 返回a的int类型\n\n4.复合类型\n复合类型，由基本类型构成C++中的复合类型包括数组结构指针类\n\n4.1 拼接字符串常量C++中，由空白字符分隔的字符串常量都会被拼接为一个\n4.2 读取一整行12cin.getline(size, ptr); //读取一整行，并丢弃换行符cin.get(size, ptr); //读取一整行，并将换行符留在输入流中\n表达式返回cin对象，因此，读取两行可以这样使用cin.getline(size, ptr).getline(size, ptr);\n4.3 string类简介C++98标准新增了string类型对于字符串，string隐去了数组特性，让它更像普通类型下面程序展示了基于string类型的IO方法\n12345678910111213141516string fName; //不需要提前指定大小，大小可变string lName;string description&#123;&quot;description: &quot;&#125; // 同样也可以初始化;string container;cout &lt;&lt; &quot;Enter your first name and last name:&quot; &lt;&lt; endl;getline(cin, fName), getline(cin, lName);// cin没有处理string的方法，所以需要额外使用getlinecout &lt;&lt; &quot;Enter your desciption&quot; &lt;&lt; endl;getline(cin, container);description += container; // 忽略数组特性，像对象一样操作cout &lt;&lt; &quot;your name is: &quot; &lt;&lt; fName &lt;&lt; &quot; &quot; &lt;&lt; lName &lt;&lt; endl;cout &lt;&lt; description &lt;&lt; endl;cout &lt;&lt; description[2] &lt;&lt; endl;\n\n4.4 枚举12enum orientation&#123;west, east, north, south&#125;;enum &#123;left, right, up, down&#125;;\n一次性定义多个整形常量也可以给枚举取名，限定枚举变量的值\n4.5 使用new分配内存1234567int * newptr = new int;int * newarray = new int [10];int * mallocptr = malloc(sizeof(int));delete int;delete [] int;free(mallocptr);\nnew，是C++提供的新关键字，用于动态分配内存它与malloc的不同点在于\n\nnew分配的是称为“堆”的自由内存，malloc是“栈”内存\nnew分配的内存必须用delete释放，malloc需要free\nnew分配的数组，必须要用数组形式对应释放\n\n4.6 auto类型的使用方法auto container = /*一个指向存放整形数组指针数组的指针*/在变量类型复杂时，可以直接用auto代替\n4.7 vector与array模板类简介12vector&lt;int&gt; vi(n); // n可以是变量array&lt;double, n&gt; vd; // n可以是变量\nvector与array提供了动态管理数组的功能，可以代替数组而且更安全可以使用vector与array的类方法来动态分配数组，将在后面提到但是vector相比于数组，处理时间更长一些\n5.循环与关系表达式5.1 副作用与顺序点顺序点，是程序执行过程中的一个点，进行下一步之前确保对所有副作用都做出了评估在C++中，语句中的分号就是一个顺序点同时，任何完整表达式的最后都是一个顺序点如while (i++ &lt; 5)，i++ &lt; 5是一个完整条件表达式，因为他是while循环的测试条件\n5.2 编写延时循环头文件ctime中提供了clock_t类型与CLOCK_PER_SECOND常量目的是为了统一ctime在不同系统上的运行结果\n12345678910float seconds;cout &lt;&lt; &quot;Enter the delay time, in seconds:&quot;;cin &gt;&gt; seconds;clock_t delay = seconds * CLOCKS_PER_SEC; // 计算延时的时间戳cout &lt;&lt; &quot;delaying...&quot; &lt;&lt; endl;clock_t start = clock();while (clock() - start &lt; delay); // 这种循环等待的方式实际上会占用电脑大量资源cout &lt;&lt; &quot;done!&quot; &lt;&lt; endl;\n\n5.3 基于范围的for循环12345double x[4]&#123;0.1, 5.0, 2.3, 4.2&#125;;for (double i : x) // x必须是数组或者容器类型    cout &lt;&lt; i &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;\n对于使用for循环遍历容器元素，C++11提供了遍历的新特性\n6.输入与输出6.1 getchar()与putchar()的代替12cin.get();cin.put(ch);\n\n6.2 cin.get的重载类型cin.get有三种重载类型\n\nch = cin.get() 不传递任何参数，读取一个字符，返回读取的字符\ncin.get(ch) 传递一个char类型参数，读取一个字符，返回cin的引用，可以直接用作判断条件\ncin.get(str, size) 传递一个c风格字符串与大小，读取一整行，并将换行符留在输入里，返回cin的引用\n\n6.3 文件尾条件使用文件尾条件作为循环结束条件要判断读取完毕，相比于读特定字符，此方案使用场景更广泛一些\n同时，键盘输入可以通过ctrl + z来模拟文件结尾\n1234cin.eof(); // 检测输入流是否到文件结尾cin.fail(); // 检测是否读取失败(包含读取到文件结尾的情况)cin.bad(); // 检测读取时是否发生严重错误cin.good(); // 检测读取状态是否正常\n以上四种cin的方法可以检测cin的读取状态四种状态都是在读取后判断，也就是执行一次读取操作后，再判断状态读取到eof时，eof与fail状态都是1\n同时，可以将cin对象作为一个布尔值使用如if (cin)，这将返回cin的读取状态\n对循环结尾条件的理解流程：先读取-&gt;再判断是否达到结束条件while (cin &gt;&gt; temp)与while((ch = cin.get()) != EOF)实际上是将“读取”与“判断”的操作合成一句了先从输入流读取，再判断是否读到文件结尾\n6.4 将文件作为输入输出流c++提供了fistream&#x2F;fostream类，它给我们提供了文件读取类似cin与cout的接口统一了文件输出输入和标准输入输出流的操作\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define IFILE &quot;Avg.in&quot;#define OFILE &quot;Avg.out&quot;#define NAMESIZE 1024int main(void)&#123;    using std::cout, std::cin, std::endl, std::vector;    std::ofstream outFile;    std::ifstream inFile;    vector&lt;double&gt; data;    double temp, res = 0.0;    outFile.open(OFILE); // cin与cout是单例，但fsteam类可创建多个对象    inFile.open(IFILE);    if (!inFile.is_open() || !outFile.is_open()) // is_open方法判断是否打开成功    &#123;        cout &lt;&lt; &quot;Unable to open &quot;        &lt;&lt; IFILE &lt;&lt; &quot; or &quot;        &lt;&lt; OFILE &lt;&lt; endl;        exit(EXIT_FAILURE); // 没有打开成功所以不用关闭    &#125;    while (inFile &gt;&gt; temp) // 只要还有数据，    &#123;        data.push_back(temp);        res += temp;    &#125;    if (inFile.eof()) // 跳出循环，检查状态（读取完成之后发生的）    &#123;        if (data.size() == 0)            cout &lt;&lt; &quot;No value readed!&quot; &lt;&lt; endl;        else        &#123;            cout &lt;&lt; data.size() &lt;&lt; &quot; value&quot; &lt;&lt; (data.size() &gt; 1 ? &quot;s &quot; : &quot; &quot;) &lt;&lt; &quot;readed&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;The avg is: &quot; &lt;&lt; res / data.size() &lt;&lt; endl;            cout &lt;&lt; &quot;Now putting results to &quot; &lt;&lt; OFILE &lt;&lt; endl;            // 像cin/cout一样使用            outFile &lt;&lt; data.size() &lt;&lt; &quot; value&quot; &lt;&lt; (data.size() &gt; 1 ? &quot;s &quot; : &quot; &quot;) &lt;&lt; &quot;readed&quot; &lt;&lt; endl;            outFile &lt;&lt; &quot;The avg is: &quot; &lt;&lt; res / data.size() &lt;&lt; endl;            outFile.close();            inFile.close();            exit(EXIT_SUCCESS); // 成功执行        &#125;    &#125;    else if (inFile.fail())        cout &lt;&lt; &quot;Type dismatch!&quot; &lt;&lt; endl;    else        cout &lt;&lt; &quot;Unknown Error!&quot; &lt;&lt; endl;    outFile.close();    inFile.close();    exit(EXIT_FAILURE);&#125;\n补充：exit()与return的区别\n\nexit与return的级别\nreturn是语言级别的，它将控制权交给上一个调用的函数\nexit是系统级别的，它将控制权交给操作系统，返回值也是\n\n\nexit与return的行为\n在main函数中，exit与return行为几乎一样\n而在main函数之外，exit能直接将控制权交给系统\n\n\n最后，在main函数里使用return其实最后也会调用exit函数\n\n7.函数7.1 数组参数传递使用数组对函数传参时，必须同时传入数组指针与数组大小\n12f_show(const double array[], int n); // 使用const显式指定数组不会被修改f_modify(double array[], int n); // 使用[]说明array是一个数组\n如果使用容器类vector或者array就不会出现需要传递数组大小的问题直接使用.size()方法获取大小即可\n7.2 使用数组区间的函数另一种传递数组范围的方法，是两个指针定义开始与结束的区间通常，结束指针被规定为“超尾”的，指向要处理的末尾值的后一位对于要处理数组区间的函数来说，这个更像是一种语法糖因为不需要通过开始指针和处理个数来指定区间\n7.3 常量指针的传递常量指针指向的变量不能被修改，就算变量本身不是常量\n函数参数传递时：const * -&gt; const * (√)* -&gt; const * (√)const * -&gt; * (x)所以声明函数时，尽量在应该使用const指针的地方使用它这样能确保同时兼容\n12const int * array;int * const array;\n语句一表示，指针指向的是一个const量，不能通过指针修改这个量语句二表示，指针是一个const量，不能修改这个指针指向的地址\n同时，教材还给出了一个很离谱的例子我们来逐步分析下\n1234567const int **pp2 // 指向常量int的指针的指针int * pp1; // 指向int的指针const int n; // 常量intpp2 = &amp;pp1; // 可以，将int指针赋值给常量指针*pp2 = &amp;n; // 可以，常量指针接受常量指针*pp1 = 10; // pp1不是常量指针，但得到了常量指针的地址，这样就可以用非常量指针修改常量\n因此，在使用指向指针的指针时，一般不使用const\n7.4 二维数组传参首先区分一下定义(注：[]的优先级要高于*)\n\n* a[3] 大小为3的数组，数组里存了指针\n(*a)[3] 指针，指向大小为3的数组\na[][3] 同上面的\n(*a)[i] 指针，指向变长数组\n\n7.5 auto与typedef对类型的简化当一个类型特别复杂时，可以使用typedef来定义，之后每一次引用typedef即可同时也可以使用auto类型，来自动判断\n8.函数进阶8.1 C++内联函数适用情况：函数本身代码执行时间很短，但需执行多次的情况它的适用范围和#define的宏定义函数很像，但前者行为更像一个函数，功能更强大inline int add(int a, int b)内联函数的例子注：内联函数无法递归，但既然你都内联了，为啥还要递归\n8.2 引用变量引用除了隐式使用指针的功能外，还有其他特性\n\n引用必须在声明时赋值，且引用完不能更改引用的指向\nint &amp; num = a; 相当于 int * const num = &amp;a;\n\n\n引用创建的对象，其功能和变量原型一样，只不过换了名字\n例如int &amp; num = a;然后&amp;num，&amp;num效果与&amp;a相同\n\n\n\n引用变量在函数参数传递当中的应用\n\n和传递指针的行为类似\n只不过省去了传参时求地址和使用时解引用的操作\n\n\n在传递大规模数据时\n使用const int &amp; num = a来定义常量引用\n再给函数传递参数时，能够保证大数据不被再拷贝一遍，也能保证源数据不被修改\n\n\n\n注意：引用在参数传递时，更多的是针对结构或者类给函数传参的情况\n8.3 在函数中使用引用const ob &amp; accumulate(ob &amp; a, const ob &amp; b)该函数声明：\n\n传递一个ob类型的引用a，可修改\n传递一个ob类型的引用b，不可修改\n返回一个ob类型的引用，且该引用不可当作赋值符号左值\n例如accumulate(a, b) = c，若返回值不是const类型，则返回对象会被修改为c的值\n\n\n\n同时，不能将函数内的变量当作引用返回，如\n12345ob &amp; foo(ob &amp; a)&#123;    ob b;    return b; // 错误的，因为离开函数b就会消失&#125;\n正确的做法是将参数中的引用返回\n8.4 对象、继承与引用8.5 补充：cout输出格式格式个鸡毛！要格式用printf，方便得多效率还高\n","slug":"C-教程","date":"2025-10-24T04:53:47.000Z","categories_index":"tutorial","tags_index":"C++","author_index":"猫冰"},{"id":"0beed5709ac36fd358d79f96dd27d6a4","title":"WinUI3教程","content":"0.前置知识\nGUI\n\n即Graphic User Interface，它提供用户友好的图像操作界面\n\n\nCLI\n\n即Command-Line Interface，命令行交互，一般开发者在使用\n\n\nWindows SDK\n\n即Windows Software Development Kit，微软官方给开发者提供的开发工具，相当于是访问Windows的API\n\n\n\n1.环境搭建\n首先，在设置里把开发者模式打开\n\n1.1 安装visual studio使用visual studio installer安装支持WinUI3开发的Visual studio\n1.2 安装辅助软件\nWinUI3 Gallery\nWindows Community Toolkit Gallery\nMVVM Toolkit Sample App\n\n2.创建模板应用\n使用VS创建一个C++模板WinUI3应用接下来将分别解释模板的内容\n\n","slug":"WinUI3教程","date":"2025-10-23T11:34:07.000Z","categories_index":"tutorial","tags_index":"C++,GUI-Development","author_index":"猫冰"},{"id":"f953a678ee781dfc0167a1b2b1c56f02","title":"算法笔记","content":"0.本节课内容列表\n排序\n快速排序\n归并排序\n\n\n二分\n整数二分\n浮点数二分\n\n\n\n课时要做的\n\n理解算法思想课后要做的\n理解并且背（快速默写模板）\n默写，用题来练默写\n重复默写模板\n\n1.排序1.1快速排序性质：平均时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2)\n主要思想\n\n最核心的思路：分而治之，将大问题分成一个个小问题\n具体实现\n定义一个左边界和右边界，圈出范围\n在范围里随机取数，一般取中间的，设为x\n将小于x的数排在x左边，大于的排在右边\n此时范围被分为两部分：左半小，右半大\n继续对左半与右半执行一遍这个过程\n\n\n\n代码范例，最核心的代码段是quick_sort\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10; // + 10防止数组越界，是一种缓冲区int n;int a[N];void quick_sort(int * a, int l, int r) //l表示left，r表示right&#123;    if (l &gt;= r) return;        /**    * l + r &gt;&gt; 1表达式与(l + r) / 2效果一样    * 但是更快而且更简便    *     * l + r &gt;&gt; 1默认是向下取整    * 使用 l + r + 1 &gt;&gt; 1可以向上取整    *     * 同时，将x去中间的一个数可以避免死循环    */    int x = a[l + r &gt;&gt; 1], i = l - 1, j = r + 1;    while (i &lt; j)    &#123;        do i++; while (a[i] &lt; x);        do j--; while (a[j] &gt; x);        if (i &lt; j) swap(a[i], a[j]);    &#125;        /**    * 这里要么写l, j 要么写l，i - 1    * 因为最后要将数组一分为二    * i 与 j的大小就有两种情况    * - i == j，此时两种方法的效果是一样的    * - j &lt; i，此时j指向数组的左半部分，就不能向左偏移了，i同理    */    quick_sort(a, l, j);    quick_sort(a, j + 1, r);&#125;int main(void)&#123;    scanf(&quot;%d&quot;, &amp;n); //用scanf读取数据比cin要快一点    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);        quick_sort(a, 0, n - 1);        for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, a[i]);        return 0;&#125;\n1.2 归并排序性质：时间复杂度稳定为nlogn\n思想\n\n将数组不断划分，分为很小的部分\n对小部分进行排序，这下我们得到了两个顺序数组\n将两个小部分合成，又得到了新的顺序数组\n不断合成，最后结果为原来的大数组\n\n代码实现\n1234567891011121314151617181920void merge_sort(int * a, int l, int r)&#123;    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;        // 切分操作    merge_sort(a, l, mid), merge_sort(a, mid + 1, r);        //排序操作    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)    &#123;        if (a[i] &lt;= a[j]) t[k++] = a[i++];        else t[k++] = a[j++];    &#125;    while (i &lt;= mid) t[k++] = a[i++];    while (j &lt;= r) t[k++] = a[j++];        for (i = 0, j = l; j &lt;= r; i++, j++) a[j] = t[i];&#125;\n\n2.二分2.1 整数二分有单调性一定可以二分，二分不一定需要单调性二分思想的本质\n\n现有一数组，有一值，在数组里找值\n通过对数组中点性质的比较，可以缩小值的范围\n不断缩小，最后精确找到值\n\n代码实现\n123456789101112131415161718192021222324// 最终结果：l == r，指向答案// 特点：这种模板不存在找不到的情况，找不到需要按照题意单独判断// 特点：一定可以把符合性质的范围二分出来// 选择：当check为true使，右边界收缩时，就用第一种，反之第二种int bsearch1(int l, int r)&#123;    while (l &lt; r)    &#123;        mid = l + r &gt;&gt; 1;        if (check()) r = mid;        else l = mid + 1;    &#125;    return l;&#125;int bsearch2(int l, int r)&#123;    while (l &lt; r)    &#123;        mid = l + r + 1 &gt;&gt; 1;        if (check()) l = mid;        else r = mid - 1;    &#125;&#125;\n2.2浮点数二分和整数二分类似，只不过不用考虑向下或是向上取整问题代码实现\n1234567891011double bsearch_3(double l, double r)&#123;    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求    while (r - l &gt; eps)    &#123;        double mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;    &#125;    return l; //返回l或者r的一个&#125;\n3.高精度三种情况\n\n大整数相加（数量级为位数10^6）\n大整数相减\n大整数乘小整数（数量级大整数位数10^6，小整数小于10^5）\n大整数除小整数\n\n3.1 大整数相加1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5 + 10;vector&lt;int&gt; add(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) //这里加上引用，也能防止拷贝数据节省内存&#123;    vector&lt;int&gt; c;    int t = 0; //所有的位处理，都用t完成        //这里很妙，不用考虑数组越界的问题    //就是不管三七二十一继续循环，在代码块里判断有没有越界就是了    for (int i = 0; i &lt; a.size() || i &lt; b.size(); i++)    &#123;        if (i &lt; a.size()) t += a[i];        if (i &lt; b.size()) t += b[i];                c.push_back(t % 10);        t = t / 10;    &#125;        if (t) c.push_back(t);    return c;&#125;int main(void)&#123;    string a, b; //用string有两个好处，一是不用考虑越界问题，二是可以动态分配内存    vector&lt;int&gt; n1, n2, n3; //用vector也有动态分配内存的好处        cin &gt;&gt; a &gt;&gt; b;    for (int i = a.size() - 1; i &gt;= 0; i--) n1.push_back(a[i] - &#x27;0&#x27;);    for (int i = b.size() - 1; i &gt;= 0; i--) n2.push_back(b[i] - &#x27;0&#x27;);        n3 = add(n1, n2);        for (int i = n3.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, n3[i]);&#125;\n\n核心思路\n\n字符串读取大整数\n用数组逆序存储\n用数组进行计算\n逆序输出\n\n3.2 大整数除法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//判断是否a &gt;= bbool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b)&#123;    if (a.size() &gt; b.size()) return true;    else if (a.size() &lt; b.size()) return false;    else&#123;        for (int i = a.size() - 1; i &gt;= 0; i--)        &#123;            if (a[i] &gt; b[i]) return true;            else if (a[i] &lt; b[i]) return false;        &#125;        return true;    &#125;&#125;// 默认a &gt;= b// 不取minus是因为内置函数有这个名vector&lt;int&gt; sub(vector&lt;int&gt; a, vector&lt;int&gt; b)&#123;    vector&lt;int&gt; c;    for (int i = 0, t = 0; i &lt; a.size(); i++) // a, b, c共用i的原因是，它们的定位都是相同的    &#123;        t = a[i] - t;        if (i &lt; b.size()) t -= b[i];                c.push_back((t + 10) % 10);        if (t &lt; 0) t = 1;        else t = 0;    &#125;        while (c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back();    return c;&#125;int main(void)&#123;    if (cmp(n1, n2))    &#123;        auto n3 = sub(n1, n2);        for (int i = n3.size() - 1; i &gt;= 0; i--) cout &lt;&lt; n3[i];    &#125;    else    &#123;        auto n3 = sub(n2, n1);        cout &lt;&lt; &quot;-&quot;;        for (int i = n3.size() - 1; i &gt;= 0; i--) cout &lt;&lt; n3[i];    &#125;&#125;\n\n3.3 大整数乘小整数12345678910111213141516vector&lt;int&gt; multi(vector&lt;int&gt; &amp;a, int &amp;b)&#123;    vector&lt;int&gt; c;    int t = 0;        for (int i = 0; t || i &lt; a.size(); i++)    &#123;        if (i &lt; a.size()) t += a[i] * b;        c.push_back(t % 10);        t = t / 10;    &#125;        while (c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back();        return c;&#125;\n直用小整数乘上大整数的每一位如果再将小整数读成数组一位一位算就复杂了\n3.4 大整数除小整数1234567891011121314151617181920//为了保证代码的统一性，a同样是逆序//虽然a顺序用除法处理起来更方便一些vector&lt;int&gt; div(const vector&lt;int&gt; &amp;a, int b, int &amp;r)&#123;    vector&lt;int&gt; c;    r = 0;        for (int i = a.size() - 1; i &gt;= 0; i--)    &#123;        r = r * 10 + a[i];        c.push_back(r / b);                r = r % b;    &#125; //最后不需要额外的边界处理        reverse(c.begin(), c.end()); //c是反着输出的，所以要调转顺序        while (c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back();    return c;&#125;\n\n4.前缀和与差分4.1 前缀和12S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1]\n\n为什么需要前缀和？当需要重复计算区间[l, r]之间的数据和的时候，每次计算的时间复杂度是O(n)但计算一次前缀和数列后，每一计算的时间复杂度为O(1)\n4.2 前缀和矩阵123S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n\n补充说明：矩阵的和，等于从某个坐标开始，左上角所有数字的和\n4.3 差分12给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c只需要一个insert(l, r, c)操作\n\n差分就是前缀和的逆运算，也就是给定数组，算差分数组，数组就是差分数组的前缀和数组使用情况：在某个区间给所有数加上一个数\n差分不需要额外操作来构建，只需构想一个空差分组，用insert方法在[i, i]处加上ai即可构建\n4.4 差分矩阵123给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c同样只需要一个insert操作","slug":"算法笔记","date":"2025-10-22T12:35:39.000Z","categories_index":"algorithm","tags_index":"note","author_index":"猫冰"},{"id":"326c974c2dd33a5c1c93eb6f0ddf6329","title":"git分支部分教程","content":"\n得先说明，这些东西都是写给我自己看的用于梳理自己的思路，以及之后复习用所以某些地方写的不是很清楚\n\n0.git分支特性简介git的分支模型具有轻量的特点，支持在工作流程中频繁地使用分支和合并，这使得它在一众版本控制系统中脱颖而出git保存数据的方式：保存某一时刻的快照\n1.git提交对象与分支1.1 提交对象概念与新建提交对象git add .git commit -m &quot;some changes&quot;\n第一条指令将根目录的文件全部存储在暂存区（可以理解为缓冲区），方便之后的commit提交第二条将指令将暂存区里的文件提交到分支上，这一步，git做了以下的操作：\n\nblob对象，指向每个提交的文件，保存者该文件的当前快照和哈希值\n快照，相当于给文件存了个档，记录了当前文件的状态\n哈希值，方便git检测文件是否改变\n\n\n树对象，指向blob对象的索引，记录着文件结构\n提交对象，指向树对象，同时包含着提交的信息\n\n上面对象的包含关系呈现如下：\n\n提交对象\n树对象\nblob对象\nblob对象\nblob对象\n\n\n\n\n\n这样，一个提交对象就形成了，不同提交对象之间的关系呈现如下提交对象1 &lt;- 提交对象2 &lt;- 提交对象3\n1.2 分支概念与新建分支git的分支，本质上是指向不同提交对象的指针，git的默认分支为master使用git branch demo会在当前提交对象上新建demo分支这样，我们就有两个分支，master与demo，它们都指向同一个提交对象\n那么，两个分支指向同一个提交对象，git是如何确定当前是在那个分支上的呢那就是Head头指针，它没有特殊的含义，只是标识当前位于哪个分支上（可以理解当前的工作路径）\n可以使用git log --oneline --decorate查看分支指向的提交对象\n1.3 分支切换git checkout demo这条命令将head指针切换到demo分支上此时再新建提交对象，提交对象就会在当前head指针所在的分支上创建同时将head指针移动到新建的对象上\n1.4 查看提交对象结构git log --oneline --decorate --graph --all显示提交对象的结构，以及各个分支指向的地方\n2.git分支的合并git中的分支合并有两种类型\n2.1 快进合并如果main分支所在的提交对象是demo分支的父对象git checkout maingit merge demogit所做的就是直接将main分支移动到demo分支所在的位置\n2.2 融合合并main分支不是demo分支的父提交对象此时融合就是将两个提交对象融合到一起，形成一个新的提交对象并且将分支移动到新的提交对象上\n此时，如果两个提交对象的内容有冲突，git就会要求你处理冲突冲突处理完毕后才能真正新建提交对象\n3.git分支的管理3.1 检查分支状态git branch查看当前有哪些分支，可以添加参数-v查看详细内容git branch --merged查看与当前分支合并了的分支git branch --no-merged查看未与当前分支合并的分支\n3.2 常见的分支开发工作流\n长期分支\n提交对象实际上应该是线性的\n分为main、develop、top三个分支\n每个分支由一个分支指针控制\n\n\n主题分支\n不同的分支由主干分支上生发出来，提交对象是树状的\n可以有多个不同的分支\n\n\n\n长期分支和主题分支可以同时进行，可以将长期分支的main、develop、top分支当成主题分支的主干\n3.3 远程分支常见交互远程分支的命令\n\ngit remote add 远程服务器名 url添加git源，并为其命名\ngit pull origin main将远程分支拉取到当前分支\n这条命令相当于git fetch origin main+git merge origin main\n先拉取，在融合（解决冲突）\n\n\ngit push origin main将当前分支推送到远程分支\n如果本地与远程分支冲突，会推送失败\n这种情况要先拉取解决冲突，再推送\n\n\ngit branch -u origin main将当前分支与远程分支绑定\n绑定并不会实时跟踪远程分支的状态\n只是起到简化代码的作用，如git push origin main简化为git push\n\n\ngit checkout -b demo origin/demo在远程分支的地方创建一个本地分支，并将两者绑定\n捷径：git checkout --track origin/main\n或：git checkout main，直接追踪远程得到main分支\n\n\ngit push origin --delete main删除一个远程分支\ngit remote -v查看远程git源列表\n\n","slug":"git教程","date":"2025-10-16T14:46:06.000Z","categories_index":"git","tags_index":"tutorial","author_index":"猫冰"},{"id":"79fe4e631ac71a379c3a62ac37d71308","title":"个人博客建站教程","content":"\n这是一个建站基础教程，主要是为了熟悉流程，更多需要技术个性化的东西之后再详细学习\n\n索引\n准备工作\n安装nodejs\nhexo生成框架\n部署上线\n修改域名\n问题指南\n补充知识点\n\n0.建站之前需要准备的（windows环境下）\nwindows下的linux环境（方便网站管理）-&gt; wsl教程\n网站数据托管github（方便存储网站内容）\n博客框架hexo（方便网站内容管理）\n网站部署netlify（可以直接通过github库部署）\n在阿里云购买的域名\n\n1.linux下配置必要的工具 使用wsl在windows下建立一个linux环境，我这里选择的是ubuntu版本\n接下来，下载nodejs，它自带npm包管理软件sudo apt install nodejs\n安装完成后检查安装情况node -vnpm -v出现版本提示就算安装成功\n同时记得修改以下npm的安装源，因为默认源在国内很慢\n12npm config set registry https://registry.npm.taobao.org #设置为淘宝源npm config get registry #查看更新完成后的源\n\n\n补充#1：什么是nodejs?nodejs（我自己的理解，可能不准确）\n\n是一个基于chrome V8引擎开发的C++程序\n可以简单的理解为Javascript的运行环境，是一个编译器\nnodejs让Javascript能在前后端都运行npm\n是基于nodejs衍生出来的\n一个Js包管理工具，相当于是下载JS包的app store\n\n2.使用hexo生成博客框架 使用npm安装hexo框架npm install hexo-cli -g # 全局安装hexo命令行工具\n安装好后，切换到对应的文件夹，使用hexo init &quot;项目名&quot;生成一个新的hexo框架\n框架生成完成后，要格外关注项目里面的这几个文件(夹)\n\n_config.yml（重点关注）\n为全局配置文件，网站的很多信息都在这里配置，比如说网站名称，副标题，描述，作者，语言，主题等等。具体可以参考官方文档：https://hexo.io/zh-cn/docs/configuration.html。\n\n\nscaffolds\n骨架文件，是生成新页面或者新博客的模版。可以根据需求编辑，当hexo生成新博客的时候，会用这里面的模版进行初始化。\n\n\nsource\n这个文件夹下面存放的是网站的资源，包括\n_posts：存放网站的帖子，也就是.md文件\n_drafts：存放网站的草稿\n\n\nthemes\n网站主题目录，hexo有非常丰富的主题支持，主题目录会存放在这个目录下面。\n我们后续会以默认主题来演示，更多的主题参见：https://hexo.io/themes/\n\n\n\nhexo new post &quot;MyBlog.md&quot;hexo generatehexo server三条指令合在一起的意思是，新建MyBlog.md这个帖子，生成静态文件，最后在本地运行服务器\n\n发布以及编辑博客的教程在官网有详细的说明\n生成静态文件，可以理解为C编译器将C语言编译为机器语言的过程，hexo将内容编译成浏览器看得懂的HTML CSS JS文件\n在本地运行服务器，可以用作本地调试用，编辑完后看看网站的效果\n\n3.使用netlify将网站部署上线将代码上传到github上，netlify可以直接导入只给出操作，命令说明见：git教程\n1234567git remote add origin &quot;git仓库链接&quot;git branch -M maingit add .git commit -m &quot;生成了我的第一个博客&quot;git push -u origin main#输入用户名和密码\n\n将代码推送到github后，就可以使用netlify部署了登录netlify后，从github导入项目，再配置网站\n此时，网站已经部署上线，可以通过netlify中给出的网址访问\n4.给网站分配域名\n在域名管理网站购买域名，这里拿阿里云举例\n在netlify的管理域名处添加域名\n在阿里云将域名的DNS服务器指向改为netlify的\n域名分配成功\n\n具体解释见后文的域名工作原理\n999.问题指南1.使用hexo server时，nodejs与hexo的版本不适配问题当时使用hexo server时，报错\n12Error [ERR_REQUIRE_ESM]: require() of ES Module /home/catice/tw/node_modules/strip-ansi/index.js from /home/catice/tw/node_modules/hexo/dist/plugins/console/list/common.js not supported.Instead change the require of index.js in /home/catice/tw/node_modules/hexo/dist/plugins/console/list/common.js to a dynamic import() which is available in all CommonJS modules.\n同时使用npm install安装兼容时，提示\n12345npm WARN EBADENGINE Unsupported engine &#123;npm WARN EBADENGINE   package: &#x27;hexo@8.0.0&#x27;,npm WARN EBADENGINE   required: &#123; node: &#x27;&gt;=20.19.0&#x27; &#125;,npm WARN EBADENGINE   current: &#123; node: &#x27;v18.19.1&#x27;, npm: &#x27;9.2.0&#x27; &#125;npm WARN EBADENGINE &#125;\n\n问题分析看到第二个提示再结合第一个，很明显是版本不兼容的问题，nodejs版本太低此时我尝试更新nodejs，使用apt upgrade nodejs，但发现已经是最新版本我又尝试给apt在/etc/apt/sources.list里换源，使用apt upgrade刷新但发现还是最新版，最后不得不安装低版本的hexo来兼容\n12345678# 卸载当前 hexonpm uninstall hexo# 清除 npm 缓存npm cache clean --force# 安装兼容的 Hexo 版本npm install hexo@7.2.0 --save\n\n2.github登录不上github从2021年8月13日，开始要求使用 token 进行命令行 Git 操作\n需要在github-&gt;我的头像-&gt;settings-&gt;developer settings-&gt;personal access token-&gt;tokens(classic)-&gt;generate new token(classic)使用生成的token登录\n3.apt下载慢使用cat /etc/apt/sources.list查看下载源若使用的是apt官方的下载源，则需换源，因为慢\n在/etc/apt/sources.list设置源\n1234deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n使用apt update从源下载包列表，换源成功\n4.cloudflare配置域名成功，但访问会弹出netlify网站不存在的提示核心原因：Netlify 需要知道你的自定义域名Netlify 有一个安全机制：它只为自己认识的域名提供服务。否则，任何人都可以随便指向它的服务器，会造成安全和管理问题。当你通过 maobing.top 访问时，请求的流程是这样的：\n\nDNS 解析成功：maobing.top -&gt; maobingbing.netlify.app 的 IP。\n请求到达 Netlify 的服务器。\nNetlify 服务器检查请求头中的 Host 字段，发现是 maobing.top。\nNetlify 在自己的数据库里查找：“我的所有站点里，有谁设置了 maobing.top 这个域名吗？”\n如果没找到，它就会抛出这个 “Netlify网站不存在” 的错误。\n\n解决方法就是在netlify里添加maobing.top域名\n1000.补充知识点域名工作原理建网站的域名管理流程如下\n\n你想去一个地方（输入域名）\n让你的智能助手（递归解析器）去查\n递归DNS解析器是：网络服务提供商（如电信、联通）或公共DNS服务商（如阿里云的223.5.5.5、谷歌的8.8.8.8）\n\n\n助手先问全球总机（根服务器）\n根服务器：是公共的，知道管理.com，.net的顶级域服务器的地址\n\n\n总机让它去问市规划局（顶级域服务器）\n顶级域服务器：知道权威域名服务器的地址\n\n\n市规划局让它去问片区物业总公司（权威域名服务器）\n权威域名服务器：如阿里云、netlify、cloudflare\n\n\n物业总公司给出了精确的门牌号（IP地址）\n助手带你精准抵达（访问网站）\n\n更改DNS解析的流程如下\n\n你提出更改物业（权威域名服务器）的请求\n让原物业找到房产管理总局（顶级域服务器）\n只能先找（权威域名服务器）更改\n不能直接在（顶级域服务器）更改\n\n\n在房产管理总局更改房子的物业（另外一个权威域名服务器）netlify在管理域名时，要求在域名购买商那里更改DNS服务器，这就是原因\n\n常见的DNS记录类型\n\nA指向一个IPV4地址\nAAAA指向一个IPV6地址\nCNAME由一个域名指向另一个域名\nNS(Name Server)就是权威域名服务器\n\nCDN的工作原理如下（重写）\n\n经过前面的一系列操作，你找到了物业（权威域名服务器）\n物业告诉你，要看房型信息，得去问存有房型信息的地方（CDN服务器）\n房型信息给出最近的能看房的地方（CMAKE）\n\n","slug":"个人博客建站教程","date":"2025-10-16T14:46:06.000Z","categories_index":"web","tags_index":"tutorial","author_index":"猫冰"}]